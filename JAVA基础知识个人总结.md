#关于java一些的日常练习sss

## java环境变量的配置

[java环境变量的配置](#java环境变量的配置)

## Java对象与类

[对象与类](#对象与类)

## Java数据类型

[primitive主数据类型](#primitive主数据类型)

[运算符号](#运算符号)

[避开关键字](#避开关键字)

[引用数据类型](#引用数据类型)

[数组](#数组)

[方法](#方法)

## 对象与类

[类](#类)

[对象](#对象)

[类与对象关系](#类与对象关系)

[类与对象的基本定义](#类与对象的基本定义)

[封装](#封装)

[继承](#继承)

[多态](#多态)

[垃圾回收机制](#垃圾回收机制)

[构造方法](#构造方法)

[静态static关键字](#静态static关键字)

[静态属性](#静态属性)

[静态方法](#静态方法)

[静态语句块](#静态语句块)

[final和static和abstract区别和使用](#final和static和abstract区别和使用)

[单例模式](#单例模式)

## 接口与内部类

[抽象类和接口](#抽象类和接口)

[异常及异常处理(Exception Handing)](#异常及异常处理)

[工具类](#工具类)




---
---


### java环境变量的配置

下面是我对应的JDK安装位置： JDK 位置：C:\Program Files\Java\jdk1.8.0_73

环境变量配置：
* (1) JAVA_HOME 编辑：
C:\Program Files\Java\jdk1.8.0_73

* (2)CLASSPATH 编辑：
%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar

* (3)PATH 点击编辑文本：
%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin

* (4)检查是否环境配置成功
 使用CMD查看环境是否配置成功：java      javac     java -version


### 对象与类

* `对象:` 对象是类的实例，有状态和行为两种属性。状态影响行为，行为影响状态。

* 对象的三个主要特性：
 > 1. 对象的行为（behavior）：可以对对象施加哪些操作、方法；
 > 2. 对象的状态（state）：当施加那些方法时，对象是如何响应的？
 > 3. 对象标识（identity）：如何辨别具有相同行为、状态的不同对象。
      ps:同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。                 
* `类:` 类是一个模板，它用来描述对象的行为和状态。类是构造对象的模板或蓝图。
        由类构造（Contruct）对象过程为创建类的实例（instance）。
* 类之间的关系：依赖（use-a）、聚合（has-a）、继承（is-a）。
* 类包含的类型变量：

>* 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
>* 方法会运用形参。调用的一方会传入实参。实参是传给方法的值，当它传入方法后就成为了形参。参数跟局部变量是一样的。它有类型与名称，可以在方法内使用。
>* 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
>* 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。

---

Java的基本数据类型
--
在java中，变量分为两种：`primitive主数据类型(基本数据类型)`、`引用数据类型` 
### primitive主数据类型
primitive主数据类型(基本数据类型)包括八种：`boolean`,`char`, `byte`,`short`,`int,lon`g,`float,double`对于变量的赋值，都是将某个变量的值赋给另一个变量；这两个变量之间并没有其他什么联系，只是在初次赋值时，其值刚好相等而已；之后则各走各路，并无任何瓜葛；
>* char类型 2字节  short 2字节,char类型与short类型之间,需要转换,比较特殊，表示正数。
>* char类型与char类型运算，晋级为Int类型,然后再进行计算。
* 隐式数据类型的顺序：

	byte < short < int < long < float < double
* 需要强制转换的顺序：

	double > float > long > int > short > byte > char(特殊，表示正数)
* 大类型转换为小类型值，需要进行强制转换：

	float c = 9.0f/2;
	double d = 9.0/2;
	d = c;	//将c赋值给d
	c = (float)d;	//强制类型转换 

* 本节要点
>* 变量有两种：primitive主数据类型和引用
>* 变量的声明必须有类型和名称
>* primitive主数据类型变量值是该值的字节所表示的
>* 引用变量的值代表位于堆之对象的存取方法
>* 引用变量如同遥控器，对引用变量使用圆点云算法可以如同按下遥控器按钮般的存取它的方法或实例变量
>* 没有引用到任何对象的音乐变量的值为null值
>* 数组一定是一个对象，不管所声明的元素是否为primitive主数据类型，并且没有primitive主数据类型的数组，只有装载primitive主数据类型的数组。
	
### 运算符号
* 1、运算符号：+ - * / %
>* int整数类型祥运算时，结果也为整数。
>* % 取模运算，取余运算：

	int c1 = 10%3;
	int c2 = -10%3;
	int c3 = 10%-3;
	int c4 = -10%-3;
	System.out.println(c1);
	System.out.println(c2);
	System.out.println(c3);
	System.out.println(c4);
	综上所述，取模运算，运算结果符号 取决于第一个数值为（正\负）

* 2、赋值运算
>* ++e 先运算 在输出  ； 先进行加减
>* e++ 先使用 在运算  ；先使用在运算
	
>>* 逻辑运算符  || 或  一真则真; && 与  一假则假;  ! 非  颠倒是非
>>* | 暗位或   需要两个或多个条件都为真 才可以通过
>>* != 不等于  ==等于   =赋值
>* 条件运算符   三目运算符

	boolean n = (4 < 2) ? true :false;
	System.out.println(n);
	对4 小于2语句进行判断 ？  真就为true ,否则为flase

* 3、运算符优先级运算 
> 优先级由高到低

 元素符号|说明|
  |-|:-:|
  `var++、var--`|后置操作符
  `+、- ``++var、--var`|(后置操作符);(后置操作符)
  type|类型转换
  !|非
 ` *、/、% `|乘法、除法、求余运算
  +、-|二元加法乘法
  < <+ > >+|比较操作符
  == !=|相等操作符
  ^|异或
  &&|条件与
  `||`|条件或
 ` = += -+ *+ /+ %=`|赋值操作符
> 按操作数多少划分
	一元操作符 > 二元操作符 > 三元操作符
> 按运算类型划分
	算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符
> 尽量多的使用括号
	括号优先级别最高
> 一元运算符，如` -、++、- -和 ! `
> 算术运算符，如` *、/、%、+ 和 -`
> 关系运算符，如 `>、>=、<、<=、== 和 != `
> 逻辑运算符，如` &、^、|、&&、|| `
> 条件运算符和赋值运算符，如 `? ：、=、*=、/=、+= 和 -= `

* 4、&和&&，|和||的用法区别:
 
     &：表示`按位"与"`、&&：表示`条件与`，两者之间的区别是：&会执行两边，不管第一个条件是否成立;
     
    				 &&只会执行一边，如果第一个条件为假，则不会走第二个条件。遵循一假则假规则。
     
     |：表示`按位"或"`、||：表示`条件或`，两者之间的区别是：||只要满足第一个条件，后面的条件就不再判断，
     
     							而|要对所有的条件进行判断。遵循一真则真原则
 
> 逻辑与或同按位与或是有一定区别的：

>> 相同点是：都能参与逻辑运算，按位与或完全可以代替逻辑与或。

>> 区别是：按位与或可以参与位运算，逻辑与或只能参与逻辑运算，逻辑与或可以“短路”，按位与或不能“短路”。	

>> 短路运算
	作用运算符：逻辑与&&，逻辑或||。
	
	如（1）：逻辑表达式：a>b && c>d
		假设a>b 为false，c>d为true，那么整个表达式结果为false;
		假设a>b 为false，c>d为false，那么整个表达式结果还为false;
	可见，a>b的结果已经决定了整个表达式的结果，而后面的c>d并不影响表达式的结果，可以说后半部分被“短路”了。
	如（2）：逻辑表达式： a>b || c>d
		假设a>b 为true，那么后半部分表达式将被“短路”;

 
  
### 避开关键字
* 类、方法、变量命名规则：
>* 名称必须以字母、下划线（）或$符号开头，不能用数字开头。
>* 除了第一个字符外，后面就可以用数字。反正不要用在第一个字符就行。
>* 主要符合上述两条规则，你就可以随意命名，但还要避开Java的保留字。
>* 对象的声明、创建、赋值有三个步骤。 
```
    Dog d    =      new Dog();
    声明     赋值    创建
```
>* pd:转义字符：\   例如：`\\` 输出一个 `\` ;   `\"` 输出一个 `"`

### 引用数据类型
除上述八种primitive主数据类型之外，其余类型都称之为引用数据类型；引用数据类型，顾名思义就是：`引用`，当一个对象赋值给一个引用变量时，那么，则表明这个引用变量是指向这个对象的；一个对象可以有多个引用；一个引用同一时刻，则只能指向一个对象；
>* 事实上没有对象变量这样的东西存在
>* 只有引用(reference)到对象的变量
>* 对于引用变量保存的是存取对象的方法
>* 它并不是对象的容器，而是类似指向对象的指针，或者可以说是地址，但在Java中文名不会也不该知道引用变量中实际装载的是什么，它只是用来代表单一的对象。只有Java虚拟机才会知道如何使用引用来取得该对象。

### 数组
* 定义：数组是一种数据结构，用来存储`同一类型`值的集合。在声明数组变量时，需要指出数组类型（数组元素类型紧跟[]和数组变量的名字。
	eg:        int[] a = new int[100];）
>* 数组中每个元素都是变量,也可以说是8中primitive主数据类型变量中的一种，不然就是引用变量。
>* 创建一个数字数组时，所有元素都初始化为0；一旦创建数组，就不能改变它的大小（尽管可以改变每一个数组元素）。
>* boolean数组的元素会初始化为`flase`,对象数组的元素则初始化为一个特殊值`null`,这表示数组还未存放任何对象。
>* java.lang.ArrayIndexOutOfBoundsException :异常而终止执行，报这种错误，我们称之为`数组下标越界`。
>* 若想获得数组中的元素个数，可以使用array`.length`。

---

方法
--
### 定义
* 1、方法是完成某个功能的一组语句，通常将常用的功能写成一个方法。定义方法就是编写一段有特定功能的代码，在程序中使用同样功能的地方，没有必要重复编写同样的代码，只要调用定义好的方法就可以。可以实现代码的重用。简化了程序的编写和维护工作。方法声明或称为定义方法。

>* 修饰符：public 、static 被称为修饰符（后续会详细讲解它们）；
>* 返回值类型：用来说明该方法运算结果的类型。如果返回其他类型，编译就可能出错；
>* 方法名：它作为调用时引用方法的标识；
>* 形参列表：在方法被调用时用于接受外部传入的变量称为形式参数简称为形参，方法的形参个数可以是0个到多个，每个参数前面要声明参数的数据类型称为参数类型；每个参数要用逗号分开。也可以一个参数都没有。
>* 方法体：它是一个语句块，执行特定的功能操作。对于有返回值类型的方法，方法体当中最后一个语句是return关键字，它的作用是把方法的执行（运算）结果返回到方法外部。	
>* return  表达式：return是关键字，作用是将return后面表达式的结果作为方法的返回值。需要注意表达式的类型，必须与方法头中声明的“返回类型”相匹配。

* 2、方法分类

> 1）根据参数个数：

>> 无参方法

>> 有参方法

>>> 参数类型为基本数据类型

>>> 参数类型为引用数据类型

> 2）根据返回值类型:

>> 有返回值的方法：

>>> 返回值类型为基本数据类型

>>> 返回值类型为引用数据类型

>> 无返回值的方法

>>> 返回值类型使用void关键字

### 总结
1、可以将一些重复执行的代码定义在方法里面，方法（method）在有些书上也被称为函数(Function )。

2、本次方法所讲解的是有它的局限性：定义主类，并且有主方法直接调用。

3、方法返回值一旦定义了，就需要使用return返回相应数据。

4、方法重载（overloading）指的是`方法名称相同`，`参数类型`及`个数`不同，同时尽量保证`返回值类型相同`。

5、递归调用需要明确`设置一个结束条件`，否则就会出现死循环，如果处理数据量过大，就有可能出现`内存溢出`。
### 方法重载
方法的重载（overload），方法的重载就是在同一个类中允许同时存在一个以上同名的方法
> 方法重载的规则
>* 方法名称相同
>* 方法的参数必须`不同`:参数个数不同 或参数类型不同
>* 方法的返回值类型可以相同，也可以不同

---

对象与类
--
 
### 类
* 什么是类
>> 把相似的对象划归成一个类。
>> 在软件设计中，类，就是一个模板，它定义了通用于一个特定种类的所有对象的属性（变量）和行为（方法）

### 对象
* 什么是对象
>  类(class) — 是对某一类事物的描述
> 对象(object) — 是实际存在的某类事物的个体,也称为实例(instance)
> 注：类是创建对象的模板，对象是类的实例。

### 类与对象关系
>* 类与对象是整个面向对象之中最为基础的组成单元，如果需要给出划分定义，类是共性的集合，而对象是某一个性的产物,所有类实际上都是描述出对象的结构。
>* 一类的共性的集合对象，除了具备以上特征（属性）之外，实际上还包括许多的行为（功能），所以根据此类产生出的对象都具备相同的行为。
>* 对象所能够操作的行为都是有类来决定的，超过类定义范畴的操作是不能够使用的
>* 类实际上的对象操作的模板，但是类不能够直接使用，但必须通过实例对象来使用。（先有类再有对象）
>* 类是不能直接使用的，对象是可以直接使用的，对象是可以通过类产生的。 
 
### 类与对象的基本定义
* 1、如果在程序之中定义类可以使用“class 类名称”的语法结构组成，而类之中主要有两点：
>* Field(属性、成员、变量)：就是一堆变量的集合。
>* methed(方法、行为)：之前见到的方法，此时方法是由对象调用的。

* 2、对象定义格式：
>* 声明并实例化对象：类名称 对象名称 = new 类名称（）；
>>* 注：引用数据类型与基本数据类型最大的不同在于需要内存的开辟及使用，所以关键字new的主要功能就是开辟内存空间。即，只要是引用数据类型想使用，那么就必须使用关键字new来开辟空间。
* 3、内存分析，首先可以给出两块内存空间的概念：
>>* 堆内存：保存每一个对象的属性内容，堆内存需要用关键字new才可以开辟内存空间
>>* 栈内存：保存一块堆内存的地址。但是为了分析方便，栈内存保存的是对象的名字。

* 4、当一个对象实例化之后那么就可以按照如下的方式利用对象来操作类的结构
>>* 对象.属性：表示要操作类中的属性内容。
>>* 对象.方法()：表示要调用类中的方法。 

* 5、当使用没有实例化对象，在程序运行时，会出现“NullPointeException”空指针指向异常，此类异常只要是引用数据类型都有可能出现。
>* 注：String 首字母大写的都是类名称，类名称都是引用类型，引用类型的默认值是空。
>*     double是基本数据类型，默认值是0.0

Java面向对象的三大特征：
--
封装、继承、多态。封装和继承几乎都是为多态而准备的

### 封装
#### 1、特征：
* 所谓封装是把对象的属性和行为结合在一个独立的系统单位内部
* 尽可能隐蔽对象的内部细节，只向外部提供接口
* 降低对象间的耦合度
* 封装的重要意义：
> 使对象能够集中而完整地描述并对应一个具体事物

> 体现了事物的相对独立性，使对象外部不能随意存取对象的内部数据

首先，属性能够描述事物的特征，方法能够描述事物的动作。封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。封装：封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。

### 2、封装的好处：
>* 实现了专业的分工。
>* 良好的封装能够减少耦合。
>* 类内部的结构能够自有修改。
>* 可以对成员进行更精确的控制。
>* 隐藏信息，实现细节。
>* 使用公有与私有这两个存取修饰符来`隐藏数据`。
>* 封装原则：将你的实例变量标记为私有的，并提供公有的getter与setter类控制存取动作。
>* 将实例变量标记为private。将getter与setter标记为public。任何有值可以被运用到的地方，都可调用方法的方式来取得该类型的值。

### 3、封装的步骤
>* 修改属性的可见性来限制对属性的访问
>* 为每个属性创建一队赋值和取值方法，用于对这些属性的访问
>* 在赋值和取值方法中，加入对属性的存取限制
>* 为了实现良好的封装，我们通常将类的成员变量声明为private，在通过public方法来对这个变量来访问。对一个变量的操作，一般有读取`getter`和赋值
`setter`2个操作，我们分别定义2个方法来实现这2个操作，一个是getXX（XX表示要访问的成员变量的名字）用来读取这个成员变量，另一个是setXX（）用来对这个变量赋值。
下面我们来看下这个例子：
```
    public class Husband {
    /*

     * 对属性的封装一个人的姓名、性别、年龄、妻子都是这个人的私有属性

     */
    private String name;

    private String sex;

    private int age;

    private Wife wife;

    /*

     * setter()、getter()是该对象对外开发的接口

     */

    public String getName() {

        return name;

    }
    public void setName(String name) {

        this.name = name;

    }
    public String getSex() {

        return sex;

    }
    public void setSex(String sex) {

        this.sex = sex;

    }
    public int getAge() {

        return age;

    }

 

    public void setAge(int age) {

        this.age = age;

    }
    public void setWife(Wife wife) {

        this.wife = wife;

    }

}
```
### 继承
#### 1、Java继承
* 定义：在Java中定义一个类时，让该类通过关键字extends继承一个已有的类，这就是类的继承(泛化)。
> 被继承的类称为父类（超类，基类），新的类称为子类（派生类）。

> 子类继承父类的所有属性和方法，同时也可以增加自己的属性和方法。

Java继承是面向对象的最显著的一个特征。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。JAVA不支持多继承，单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序，父类是子类的一般化，子类是父类的特化（具体化)继承所表达的就是一种对象类之间的相交关系，它使得某类对象可以继承另外一类对象的数据成员和成员方法。若类B继承类A，则属于B的对象便具有类A的全部或部分性质(数据属性)和功能(操作)，我们称被继承的类A为基类、父类或超类，而称继承类B为A的派生类或子类。继承避免了对一般类和特殊类之间共同特征进行的重复描述。同时，通过继承可以清晰地表达每一项共同特征所适应的概念范围在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。

#### 2、Java继承的特征：继承（inheritance）
--
> 也称泛化，继承性是子类自动共享父类属性和方法的机制，在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入自己若干新的内容

> 继承简化了人们对事物的认识和描述，有益于软件复用，是OO技术提高软件开发效率的重要原因之一

> 是类之间的一种关系，一般类与特殊类之间的关系

> 继承关系的语义：“is a kind of”
---
>* 继承关系是传递的。若类C继承类B，类B继承类A（多继承），则类C既有从类B那里继承下来的属性与方法，也有从类A那里继承下来的属性与方法，还可以有自己新定义的属性和方法。继承来的属性和方法尽管是隐式的，但仍是类C的属性和方法。
>* 继承提供了软件复用功能。若类B继承类A，那么建立类B时只需要再描述与基类(类A)不同的少量特征(数据成员和成员方法)即可。这种做法能减小代码和数据的冗余度，大大增加程序的重用性。
>* 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性。
#### 3、继承的规则：
* Java中只支持单继承，也就是说每个类只能有一个父类，不允许有多重继承
> 一个父类可以有多个子类
> 子类继承父类所有的属性和方法	

#### 4、继承的实例
```
class Person1 {

       public String name = "xiaomiao";

       public int age = 20;

}
class Student extends Person1 {

       void study() {

              System.out.println("I can study!");
       }

}
public class JiCheng {

       public static void main(String args[]) {

              Student stu = new Student();

              // stu.name = "zhangsan";

              // stu.age = 20;

              System.out.println("name=" + stu.name + ",,," + "age=" + stu.age);

       }

}
```

### 多态
#### 特征：
* 指同一个命名可具有不同的语义
* OO方法中，常指在一般类中定义的属性或方法被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为，对于子类，可用不同的方法替代实现父类的服务的方法

>* 方法的重写、重载与动态连接构成多态性； Java之所以引入多态的概念，原因之一是它在类的继承问题上和C++不同，后者允许多继承，这确实给其带来的非常强大的功能，但是复杂的继承关系也给C++开发者带来了更大的麻烦，为了规避风险，Java只允许单继承，派生类与基类间有IS-A的关系（即“猫”is a “动物”）。这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，
此外，抽象类和接口也是解决单继承规定限制的重要手段。同时，多态也是面向对象编程的精髓所在。 要理解多态性，首先要知道什么是“向上转型”。 
>* 我定义了一个子类Cat，它继承了Animal类，那么后者就是前者的父类。我可以通过Cat c = new Cat();       例化一个Cat的对象，这个不难理解。但当我这样定义时： Animal a = new Cat();这代表什么意思呢？很简单，它表示我定义了一个Animal类型的引用，指向新建的Cat类型的对象。由于Cat是继承自它的父类Animal，
所以Animal类型的引用是可以指向Cat类型的对象的。那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，
又可以抽取父类的共性。所以， 父类引用只能调用父类中存在的方法和属性，不能调用子类的扩展部分；因为父类引用指向的是堆中子类对象继承的父类；（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。） 同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。
 
### 垃圾回收机制
* 面试容易遇到的题：

从大的方面来讲，JVM的内存模型分为两大块：永久区内存（ Permanent space ）和堆内存（heap space）。栈内存（stack space）一般都不归在JVM内存模型中，因为栈内存属于线程级别。每个线程都有个独立的栈内存空间。

> 1）java垃圾回收  是自动释放该内存快

> 2）垃圾回收机制作用于堆内存当中

> 3）没有引用指向的对象 ，会被标记为垃圾

* 两种提示垃圾回收机制：

> 1）System.gc();  提醒系统进行垃圾回收（至于效率、怎末回收，无权干涉）

> 2）.Finalize() ：当某个对象被系统收集为无用信息的时候,finalize()将被自动调用,但是jvm不保证finalize()一定被调用,也就是说,finalize()的调用是不确定的,这也就是为什么sun不提倡使用finalize()的原因


### 垃圾回收的两种机制详解：
* 1、垃圾回收（Garbage Collection，GC），JDK7以后使用G1（Garbage First）机制：
当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收机制作用于堆内存，与栈内存无关。
垃圾回收机制是JVM内部运行的一个优先级比较低的后台线程，自动进行垃圾回收。它是保证程序健壮的主要手段，不用程序员参与，避免了由于程序员忘记回收内存而引起的内存泄漏，同时也避免了回收内存带来的代码繁琐。

* 2、对象会被回收情况：
> 1）对象的引用被赋值为
```
	null： Person p = new Person( );   p = null;
```
> 2）使用的匿名对象：
```
	new Person( ).sayHello( );
```
> 3）超出生命周期的，如：
```
	for( int i = 0; i< 100; i++){
		Person p = new Person( );
	  }	
```
这里，创建了100个对象，循环赋值给变量p，每结束一次循环，变量p就超出生命周期，对象变为垃圾。


* 3、System.gc（）
> (1) GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。
 
> (2) 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
 
> (3) 垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，当一个对象不再被引用的时候,按照特定的垃圾收集算法来实现资源自动回收的功能。
 
> (4) System.gc();就是呼叫java虚拟机的垃圾回收器运行回收内存的垃圾。
 
> (5) 当不存在对一个对象的引用时，我们就假定不再需要那个对象，那个对象所占有的存储单元可以被收回，可通过System.gc()方法回收，但一般要把不再引用的对象标志为null为佳。
 
> (6) 每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。 Runtime.getRuntime().gc();
 
> (7) java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。
 
> (8) 唯一的区别就是System.gc()写起来比Runtime.getRuntime().gc()简单点. 其实基本没什么机会用得到这个命令, 因为这个命令只是建议JVM安排GC运行, 还有可能完全被拒绝。 GC本身是会周期性的自动运行的,由JVM决定运行的时机,而且现在的版本有多种更智能的模式可以选择,还会根据运行的机器自动去做选择,就算真的有性能上的需求,也应该去对GC的运行机制进行微调,而不是通过使用这个命令来实现性能的优化。

* 4、Finalize（）
> 注意：如果你熟悉C++，那你知道C++允许你为一个类定义一个撤消函数（destructor ），它在对象正好出作用域之前被调用。Java不支持这个想法也不提供撤消函数。finalize() 方法只和撤消函数的功能接近。当你对Java 有丰富经验时，你将看到因为Java使用垃圾回收子系统，几乎没有必要使用撤消函数。

> finalize的工作原理应该是这样的：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作.

> finalize()在什么时候被调用?有三种情况:

> 1.所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候.

> 2.程序退出时为每个对象调用一次finalize方法。

> 3.显式的调用finalize方法

除此以外,正常情况下,当某个对象被系统收集为无用信息的时候,finalize()将被自动调用,但是jvm不保证finalize()一定被调用,也就是说,finalize()的调用是不确定的,这也就是为什么sun不提倡使用finalize()的原因

---

### 构造方法
* 1、构造方法（构造器，Constructor）
> 没有返回值  与类名相同  有重载方法 this调用

> 构造方法也是方法，但是它是特殊的方法而已
> 所有的对象都是通过构造器来创建的

* 创建对象：类名   对象名 = new   构造方法（）;
* 构造器（构造方法/构造器，Constructor）特点：
> 构造方法名必须与类相同的名称
> 不含返回值类型，也没有void
> 不能在方法中用return语句返回一个值

* 2、构造方法作用：

构造方法用来完成对象的创建，即完成对象的实例化
> 在Java中，每个类都至少要有一个构造器
> 一个类可以不写出构造方法，编译器会自动的给这个类增加一个构造器，该构造器没有任何参数，我们称之为“默认的空构造器”。 
> 编程者为该类定义了构造器，系统就不再提供默认的构造器

* 3、构造方法重载：
> 构造方法可以像普通方法一样发生重载，通常一个类中不止一个构造方法，而是有多个不同参数的构造器，用户可以根据需要选择不同的构造器创建对象。
>> 一般可以使用构造器来完成对成员变量的初始化。例如：
```
public class Employee{
  int age;
  public Employee(int age){
    this.age = age;
  }  
}

```
>>有带参的构造器，那么不带参的空构造器不会自动产生。为了防止在某些情况下还想使用这样的无参数默认构造器，因此最好还是养成写出这个无参数的构造器来，以备后用。 
```
public class Employee{
  int age;
  public Employee(){
  }
  public Employee(int age){
    this.age = age;
  }  
}

```
* 4、在构造方法中，可以使用this或super调用其他的构造方法

* this super只能出现在子类构造器中，且必须是第一行。若既没有this也没有super,则默认super();

* 创建子类时，必须调用父类构造器。	

>* super()
>> 作用：调用父类的构造器
>> 只能出现在子类的构造器中，且必须是第一行
>> super()中的参数，决定了调用父类哪个构造器
>> 如果子类构造器中没有出现super，那么编译器会默认加上super()，即调用父类的空构造器，如果父类没有空构造器，编译器提示错误。
>* this()
>> 作用：调用本类的构造器
>> 只能写在构造器的第一行
>> 在同一个构造器中super()和this()不能同时出现


### 静态static关键字
* static关键字可以修饰的元素
> 属性
	注意：只能修饰属性，不能修饰局部变量。
> 方法
> 代码块
* static修饰属性：
> 所有对象共享，称为静态变量或类变量
> 不用static修饰的属性称为实例变量
* static修饰方法：
> 不需要实例化，可以直接访问，称为静态方法或类方法
* static修饰语句块：
> 类中由static关键字修饰的，不包含在任何方法体中的代码块，称为静态代码块
####  静态变量
* 用static关键字定义的变量，与局部变量相比, static局部变量有三点不同：
> 1. 存储空间分配不同
auto类型分配在栈上，属于动态存储类别，占动态存储区空间，函数调用结束后自动释放， 而static分配在静态存储区，在程序整个运行期间都不释放，两者之间的作用域相同，但生存期不同。
> 2. static局部变量在所处模块在初次运行时进行初始化工作，且只操作一次。
> 3. 对于局部静态变量，如果不赋初值，编译期会自动赋初值0或空字符，而auto类型的初值是不确定的。(对于C++中的class对象例外, class的对象实例如果不初始化, 则会自动调用默认构造函数, 不管是否是static类型)

> 静态全局变量用来表示不能被其它文件访问的全局变量和函数。为了限制全局变量/函数的作用域，函数或变量前加static使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。注意：对于外部(全局)变量，不论是否有static限制，它的存储区域都是在静态存储区，生存期都是全局的。此时的static只是起作用域限制作用，限定作用域在本模块(文件)内部。

> 静态全局变量与全局变量的差别是：静态全局变量只能被同一源文件中的函数调用，其他文件中的函数不能调用静态全局变量

> 只`允许本源文件中`所有函数使用的全局变量，则该变量需要使用的存储类型是static。

### 静态属性
* 用static修饰的属性，它们在类被载入时创建，只要类存在，static变量就存在。
> 静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

* 两种方式访问：
> 直接访问：类名.属性；

> 实例化后访问：对象名.属性 （不建议使用）
### 静态方法
* 静态方法不需要实例化，可以直接访问，访问方式：
> 直接访问：类名.方法名()

> 实例化后访问：对象名.方法名() （不建议使用）
### 静态语句块
* 一个类中由static关键字修饰的，不包含在任何方法体中的代码块
> 当类被载入时，静态代码块被执行，且只被执行一次

> 静态块经常用来进行类属性的初始化
#### final和static和abstract区别和使用
##### 一、static 修饰属性、方法和代码块

* 1.static修饰属性，这个属性就可以用类名.属性名来访问，也就是使这个属性成为本类的类变量，为本类对象所共有。这个属性就是全类公有。类加载的过程，类本身保存在文件中（字节码文件保存着类的信息）的，java会通过I/O流把类的文件（字节码文件）读入JVM（java虚拟机），这个过程称为类的加载过程。JVM（java虚拟机）会通过类路径（CLASSPATH）来找字节码文件。类变量，会在加载时自动初始化，初始化规则和实例变量相同。

特别：类中的实例变量是在创建对象时被初始化的，被static修饰的属性(类变量)，是在类加载时被创建并进行初始化，类加载的过程是进行一次。也就是类变量只会被创建一次。

* 2.static修饰方法（静态方法），会使这个方法成为整个类所公有的方法，可以用类名.方法名访问。

"类名.属性名"以及"类名.方法"访问举例：
```
class Test{

	public static String TEST_IP="静态ip127.0.0.1";
	public static void testMethod(){
	System.out.println("调用静态方法成功!");

}}

测试类

public class Test2{
	public static void main(String args[]){
	//1、通过类名.属性名调用
	System.out.println("调用的属性值："+Test.TEST_IP);
	Test.TEST_IP="新的ip127.0.0.1";//重新修改地址指向的值
	System.out.println("调用的属性值："+Test.TEST_IP);
	//2、调用静态方法
	Test test=new Test();
	test.testMethod();
}}
```
* 特别：
> （1）static修饰的方法，不直接能访问本类中的非静态(static)成员（包括方法和属性），本类的非静态方法可以访问本类的静态成员（包括方法和属性）静态方法要慎重使用(原因是静态变量会一直存在，占用资源)，且在静态方法中不能出现this关键字。
> （2）父类中是静态方法，子类中不能覆盖为非静态方法；在符合覆盖规则的前提下，在父子类中，父类中的静态方法可以被子类中的静态方法覆盖，但无多态。（在使用对象调用静态方法时，实则是调用编译时类型的静态方法）
> （3）父子类中，静态方法只能被静态方法覆盖，父子类中，非静态方法只能被非静态方法覆盖。
例：java中的main方法必须写成static的，因为在类加载时无法创建对象，静态方法可以不通过对象调用所以在类的main方法。 所在在类加载时就可以通过main方法入口来运行程序。

* 3.static修饰初始代码块，这时这个初始代码块就叫做静态初始代码块，该代码块只在类加载时被执行一次。 可以用静态初始代码块初始化一个类。动态初始代码块，写在类体中的“{}”，这个代码块是在生成对象的初始化属性是运行。这种代码块叫动态初始代码块。类在什么时候会被加载，创建对象时会加载类，调用类中静态方法或访问静态属性也是会加载类的。在加载子类时必会先加载父类，类加 载会有延迟加载原则，只有在必须加载时才会加载。

##### 二、final修饰变量、方法和类

* 1.final修饰变量:变量被final修饰，就会变成常量（常量应大写），一旦赋值不能改变（可以在初始化时直接赋值，也可以在构造方法里也可以赋值，
只能在这两种方法里二选一，必须为常量赋值）；final的常量不会有默认初始值，对于直接在初始化是赋值时final修饰符常和static修饰符一起使用。
* 2.final修饰方法，被final修饰的方法将不能被其子类覆盖，保持方法的稳定不能被覆盖。
* 3.final修饰类，被final修饰的类将不能被继承。final类中的方法也都是final的。

> 注意一：final，不能用来修饰构造方法，在父类中如果有常量属性，在子类中使用常量属性时是不会进行父类的类加载。对象一旦创建属性就不会改变。用final修饰属性，也用final修饰类（强不变模式），用final修饰属性（弱不变模式）。如：java.lang.String类，不变模式可以实现对象的共享（可以用一个对象实例赋值给多个对象变量）池化的思想，把需要共享的数据放在池中（节省资源空间，共享数据）
> 注意二：只有String类可以用“”中的字面值创建对象。在String类中，以字面值创建时，会到Java方法空间的串池空间中去查找，如果有就返 回串池中字符串的地址，并把这个地址付给对象变量。如果没有则会在串池里创建一个字符串对象，并返回其地址付购对象变量，当另一个以字面时，创建对象时则会重复上述过程。如果是new在堆空间中创建String类的对象，则不会有上述的过程。String类中的intern()方法会将在堆空间中创建的String类对象中的字符串和串池中的比对，如果有相同的串就返回这个串的串池中的地址。不变模式在对于对象进行修改，添加操作是相当麻烦的，它会产生很多的中间垃圾对象。创建和销毁的资源的开销是相当大的。这就是推荐大量使用StringBuffer，而不建议使用String的原因！String类在字符串连接时会先的效率很低，就是因为它所产生的对象的属性不能被修改的，当连接字符串时也就是只能创建新的对象。造成很多无用的资源开销和浪费！


##### 三、abstract修饰类和方法

* 1.abstract修饰类，使这个类成为一个抽象类，类将不能生成对象实例，但可以做为对象变量声明的类型，也就是编译时类型，抽象类就像当于一类的半成品，需要子类继承并覆盖其中的抽象方法。

* 2.abstract修饰方法，使这个方法变成抽象方法，即只有声明（定义）而没有实现，实现部分以";"代替。需要子类继承实现（覆盖）。

* 注意：
> （1）有抽象方法的类一定是抽象类。但是抽象类中不一定都是抽象方法，也可以全是具体方法。abstract修饰符在修饰类时必须放在类名前。 abstract修饰方法就是要求其子类覆盖（实现）这个方法。调用时可以以多态方式调用子类覆盖（实现）后的方法， 即抽象方法必须在其子类中实现，除非子类本身也是抽象类。
> （2）父类是抽象类，其中有抽象方法，那么子类继承父类，并把父类中的所有抽象方法都实现（覆盖）了，子类才有创建对象的实例的能 力，否则子类也必须是抽象类。抽象类中可以有构造方法，是子类在构造子类对象时需要调用的父类（抽象类）的构造方法。
> （3）不能放在一起的修饰符：final和abstract，private和abstract，static和abstract，因为abstract修饰的方法是必须在其子类中实现（覆盖），才能以多态方式调用，以上修饰符在修饰方法时期子类都覆盖不了这个方法，final是不可以覆盖，private是不能够继承到子类，所以也就不能覆盖，static是可以覆盖的，但是在调用时会调用编译时类型的方法，因为调用的是父类的方法，而父类的方法又是抽象的方法，又不能够调用，所以上的修饰符不能放在一起。

### 单例模式
#### 这个模式主要注重懒汉模式（饿汉模式，任选其一），注册登记式单例。（熟记）
* java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。单例模式有以下特点：
> 1、单例类只能有一个实例。
> 2、单例类必须自己创建自己的唯一实例。
> 3、单例类必须给所有其他对象提供这一实例。
* 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
* 单例模式：多个内存地址只能指向同一块内存空间！
* 一、懒汉式单例
```
//懒汉式单例类.在第一次调用的时候实例化自己
/**
 * 单例模式
 * 不允许外部new多个
 * 
 * //懒汉式单例模式
 * 一调用getInstance方法时  就实例化对象
 */
public class Singleton {  
    private Singleton() {}  
    private static Singleton single=null;  
    //静态工厂方法   
    public static Singleton getInstance() {  
	 if (single == null) {    
	     single = new Singleton();  
	 }    
	return single;  
    }  
}  
```
* Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。
（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全，如果你第一次接触单例模式，对线程安全不是很了解，可以先跳过下面这三小条，去看饿汉式单例，等看完后面再回头考虑线程安全的问题：


* 二、饿汉式单例
```
/**
	 * 饿汉式单例模式
	 * 当我一加载到静态方法区  就实例化对象
	 */
//饿汉式单例类.在类初始化时，已经自行实例化   
public class Singleton1 {  
    private Singleton1() {}  
    private static final Singleton1 single = new Singleton1();  
    //静态工厂方法   
    public static Singleton1 getInstance() {  
	return single;  
    }  
}  
```
* 饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。



* 三、注册登记式单例（spring单例，map集合，反射机制加载）
```
//类似Spring里面的方法，将类名注册，下次从里面直接获取。  
public class Singleton3 {  
    private static Map<String,Singleton3> map = new HashMap<String,Singleton3>();  
    static{  
	Singleton3 single = new Singleton3();  
	map.put(single.getClass().getName(), single);  
    }  
    //保护的默认构造子  
    protected Singleton3(){}  
    //静态工厂方法,返还此类惟一的实例  
    public static Singleton3 getInstance(String name) {  
	if(name == null) {  
	    name = Singleton3.class.getName();  
	    System.out.println("name == null"+"--->name="+name);  
	}  
	if(map.get(name) == null) {  
	    try {  
		map.put(name, (Singleton3) Class.forName(name).newInstance());  
	    } catch (InstantiationException e) {  
		e.printStackTrace();  
	    } catch (IllegalAccessException e) {  
		e.printStackTrace();  
	    } catch (ClassNotFoundException e) {  
		e.printStackTrace();  
	    }  
	}  
	return map.get(name);  
    }  
    //一个示意性的商业方法  
    public String about() {      
	return "Hello, I am RegSingleton.";      
    }      
    public static void main(String[] args) {  
	Singleton3 single3 = Singleton3.getInstance(null);  
	System.out.println(single3.about());  
    }  
}  
```
> 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。

* 饿汉式和懒汉式区别
> 从名字上来说，饿汉和懒汉，
> 饿汉就是类一旦加载，   就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
> 而懒汉比较懒，   只有当调用getInstance的时候，才回去初始化这个单例。
> 另外从以下两点再区分以下这两种方式：

* 1、线程安全：
> 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，
> 懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。

* 2、资源加载和性能：
> 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，
> 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。
* 至于1、2、3这三种实现又有些区别，
> 第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，
> > 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗
第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。

* 什么是线程安全？
> 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
> 或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。
---

### 抽象类和接口

#### 方法的覆盖
* 方法的覆盖（`override`) :还可以称为重写（`rewrite`），是对从父类中继承来的方法进行改造，只有在子类继承父类时发生。
* 方法覆盖的规则
* 在子类中的覆盖方法与父类中被覆盖的方法应具有:
> 相同的方法名
> 相同的参数列表（参数数量、参数类型、参数顺序都要相同）
> 相同的返回值类型
> 子类覆盖方法的访问权限要不小于父类中被覆盖方法的访问权限
* 在重写方法上，可以使用`@Override`注解来标明是重写方法
> `@Override`表示重写（也可以省略）：编译器验证`@Override`下面的方法名是否是父类中所有的，如果没有则报错。
```
下面是一个例子：
//接口类  Condition
public interface Condition {
	public void zhileng();
	public void zhire();
	
}
//子类
public class CoditionA implements Condition{

	@Override
	public void zhileng() {
		// TODO Auto-generated method stub
		
	}

	@Override
//	public void zhire() {
//		// TODO Auto-generated method stub
//		
//	}

}
```
* 抽象类的规则：
> 注意：
>> 抽象类不能够被实例化；	抽象类是不能使用`new`操作符来初始化的；
>> 包含的抽象方法必须在其子类中被实现，否则子类只能声明为`abstract`；
>> 子类可以覆盖父类方法，并将它定义为`abstract`。
>> 抽象方法不能为static;   抽象方法是非静态的。
> 在下列情况下，一个类必须声明为抽象类：
>> 当一个类的一个或多个方法是抽象方法时；
>> 当类是一个抽象类的子类，并且没有实现父类的所有抽象方法，即只实现部分；
>> 当一个类实现一个接口，并且不能为全部抽象方法都提供实现时

#### 接口（Interface）
* 接口定义：
> 接口中只包含常量和抽象方法，而没有变量和方法的实现;接口对类来说是一套规范，是一套行为协议;接口不是一个类，不能实例化。

* 接口注意事项：
> 接口不是一个类，没有构造器，不能被实例化

> 接口使用interface关键字来定义，而不是class

> 接口默认：常量：public static final ; 抽象方法： public abstract

> 接口在与多方面与类相似，但是它的目的是指`明相关`或者`不相关类的多个对象的共同行为`。

* 接口语法格式：
```
 [访问权限修饰符] `interface` 接口名 {  接口成员   }
```
* 接口和接口的继承:接口可以实现多继承
```
[修饰符]  interface   接口名 `extends` 接口1,接口2{ 接口的成员   }
```
* 接口和类的关系
> 类实现接口 — implements

>> 为了使用一个接口，你要编写实现接口的类

>> 如果一个类要实现一个接口，那么这个类就必须实现接口中所有抽象方法。否则这个类只能声明为抽象类

>> 多个无关的类可以实现一个接口，一个类可以实现多个无关的接口

>> 一个类可以在继承一个父类的同时，实现一个或多个接口

* 语法格式：
```
[修饰符]  class 类名 extends 类名 implements 接口1,接口2{  类的成员    }
```
> 接口可以实现多继承：
>> 用接口可以实现混合类型（主类型，副类型），在Java 中可以通过接口分出主次类型；

>> 主类型使用继承，副类型使用接口实现。

>> 接口可以使方法的定义和实现相分离，降低模块间或系统间的耦合性

* 接口与抽象类相同点与不同点

&nbsp;|变量|构造方法|方法
|-----|:---:|:---:|:---:|
抽象类|无限制|子类通过构造方法链调用构造方法，抽象类不能用new操作符来实例化|无限制
接口|所有变量必须是public static final|没有构造方法。接口不能用new来实例化|所有方法必须是公共的抽象类实例方法

---

###  异常及异常处理
* 引言：在Java中，运行时错误会作为异常抛出（而不是编译时的语法错误）。异常是一种对象，表示组织正常进行程序执行的错误或者情况。如果异常没有被处理，南无程序将会非正常终止。
  
* Throwable下包括：Error和Exception

> Error：Error层次结构描述了JAVA运行时系统内部错误和资源耗尽。
> Exception：有两个分支：一个分支是派生于RuntiomeException;另一个是分支包含其他异常（IOException）。
* 派生于Error或RunTimeException类的所有异常成为`未检查性(unchecked)异常`，所有其他的异常成为`已检查(checked)异常`。
~~注：图片在JAVA技术卷I   P473页~~
#### 异常类型
* 检查性异常（checked exception）

> 若系统运行时可能产生该类异常，则必须写出相应的处理代码，否则无法通过编译

> 非RuntimeException异常

~~注：     需要进行异常处理，否则无法进行编译~~

检查异常|说明
|--|:--:|
ClassNotFoundException|无法找到想要创建对象的类文件
IOException|I/O异常的根类
FileNotFoundException|不能找到文件
EOFException|文件结束
IllegaAccessException|请求方法不存在
InterruptedException|线程中断

* 非检查性异常（unchecked exception）

> 若系统运行时可能产生该类异常，则不必在程序中声明对该类异常的处理，就可以编译执行

> RuntimeException：运行时异常

非检查异常|说明
|--|:--:|
RuntimeException|java.lang包中多数异常的基类
ArithmeticException|算术错误，如除以0
IllegalArgumentException|方法收到非法参数
ArrayIndexOutOfBoundsException|数组下标越界
NullPointerException|试图访问null对象引用





* 规则：
> 有程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于I/O错误这类问题导致的异常属于其他异常。

> 如果出现RunTimeException异常，那么就一定是你的问题。很有道理的定理。

#### 声明异常
为了在方法中声明异常，就要在方法头中使用关键字throws, 若是多个异常，异常间用逗号隔开。
```
 public void Mwthod1() throws Exception1,Exception2   {   }
```
声明异常关键字是：`throws` 

#### 抛出异常
检测到错误的长须可以创建一个合适的异常类型的实例并抛出他，成为抛出异常
```
throw new IllegaAccessException("Wrong Arfument 出现异常啦！！");
```
抛出异常关键字是：`throw`  。

> throws声明异常  有可能出现问题的异常类型

> 次方法中有异常 所以要向上抛  谁调用我 谁需要解决异常

#### 捕获异常
* 处理异常两种方式：

> 自行处理：可能引发异常的语句封入在 try 块内，而处理异常的相应语句则封入在 catch 块内。

> 回避异常：在方法声明中包含 throws 子句，通知潜在调用者，如果发生了异常，必须由调用者处理。

* 异常处理机制

> 每次try块有异常抛出，系统会试着从上到下往每个catch块中传参，直到遇到一个类型匹配的catch块为止。

> 如上示例中最后一个catch块中的形参为Exception类型，它是所有异常类的父类，任何异常都可以传参到该块中，该块可以处理任何类型的异常。因此，这个catch块只能放到最后面，否则所有的异常都被它处理了，其他的catch块就不能分门别类的起作用了。

> 一般一个catch块中是专门处理异常的代码，在程序中这里还可以是记录日志的语句，当发生异常时记录该日志，无异常时将不会记录。

> 如果编写过程中我们违背了异常继承顺序，会产生编译错误
```
catch (ArrayIndexOutOfBoundsException e) {
   System.out.println(“Out of Bounds!”); 
}
catch (RuntimeException e) {
   System.out.println(“Runtime Exception!”);
}
catch (Exception e) {
   System.out.println(“Exception!”); 
}
```

* 规则
> 如果程序抛出多个不同类型的异常，我们需要多个catch()语句来处理。catch块，是用来捕获并处理try块抛出的异常的代码块。
```
try{}表示可能发生异常的语句
catch( )内的参数异常类对象的声明
catch{}内的语句是对异常的处理
```
> 和特殊异常类相关联的catch()块必须写在和普通异常类相关联的catch()之前。

* finally子句

> 无论异常是否产生，finally子句总是会被执行的。

> 通常在finally语句中可以进行资源的清除操作，如：关闭打开文件、删除临时文件

> 对应finally代码中的语句，即使try代码块和catch代码块中使用了return语句退出当前方法或般若break跳出某个循环，相关的finally代码块都有执行。

> 当try或catch代码块中执行了System.exit(0)时，finally代码块中的内容不被执行
```
public static void main(String[] args) {
		//异常：运行时  出现的错误，而不是编译时出现的错误
		/**
		 * 不需要对异常做处理
		 * eg:数组下标越界。。。。等
		 * 
		 * 需要对异常做处理 解决异常报错
		 * Exception in thread "main" java.lang.StackOverflowError
		 */
		int[] b;
		try {
			b = new int[5];
			//数组下标越界
			System.out.println(b[6]);
		} 
		catch (NullPointerException e) {
//			e.printStackTrace();
			System.err.println("空指针异常");
		}
		//自行捕获异常 并处理  继续向下运行
		catch (ArrayIndexOutOfBoundsException e) {
//			e.printStackTrace();
			System.err.println("数组下标越界异常");
		}
		catch(Exception e){
			System.out.println("出现异常！");
		}
		finally{
			System.out.println("不管try是否有异常，不论catch到异常与否，都会会执行finally方法！");
		}
		System.out.println("----");	
	}
	
	static void  method1(){
		method1();
	}
    void  method2() throws IOException{
    	
    	//出现检查性异常 必须解决解决方式：1、try catch  2、声明throws异常
		System.out.println("IOException");
	}
	void  method3(){
		try {
			method2();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	void method4() throws IOException{
		method2();
	}
/**
 * throw抛出异常
 * throws声明异常  有可能出现问题的异常类型
 */
	//次方法中有异常 所以要向上抛  谁调用我 谁需要解决异常
	void method5()throws IOException{
		throw new ArrayIndexOutOfBoundsException();//属于非检查性异常  
//		throw new IOException;  //属于检查性异常   
	}
```
#### 自定义异常
如果Java提供的异常类型不能满足程序设计的需要，我们可以定义自己的异常类型。用户自定义的异常类应为 Exception 类（或者Exception 类的子类）的子类
```
public class Exception_sample_5 {
  public static void main(String[] args) {
    try {
      int a = new Scanner(System.in).nextInt();
      int b = new Scanner(System.in).nextInt();
      add(a,b);
    } catch (MyException e) {
      System.out.println("输入错误!");
    }
  }
  public static void add(int a,int b)throws MyException{
    if(a<0&&b<0){
      throw new MyException();
    }else{
      System.out.println(a+b);
    }
  }
}

```
---
### 工具类
#### 常用类
* java.lang
> Java语言包，包含String、StringBuffer、Integer、Math、System。任何类中，该包中的类都会被自动导入。在java.lang不用引包.
* java.util
> 包含一些实用的工具类（ 包含list, calendar, date等类）
* java.io
> 提供多种输入/输出功能的类。 
* java.net
> 提供网络应用功能的类。

&nbsp;|java.lang包下的类|&nbsp;
:----|:----|:----
Boolean|Object|Error
Byte|String|Throwable
Character|StringBuffer|Exception
Double|StringBuilder|ClassNotFoundException
Float|System|NullPointerException
Integer|Math|NumberFormatException
Long|Runnable(接口)|RuntimeException
Short|Thread|ArithmeticException

&nbsp;|java.util包下的类|&nbsp;
:----|:----|:----
Collection(接口)|Arrays|Calender
Iterator(接口)|Set(接口)|Date
ListIterator|HashSet|Random
List(接口)|TreeSet|Scanner
ArrayList|Map(接口)|Collections
LinkedList|HashMap|&nbsp;
Vector|Hashtable|&nbsp;
Stack|TreeMap|&nbsp;

#### Object类
* Object介绍：
* 1、bject类是所有类的超类。
> Object是Java语言中唯一一个没有父类的类。(一个没有爸爸的孩子！！)

* 2、一个类可以不是Object类的直接子类，但一定是Object类的子类，Java中的每一个类都是从Object扩展来的。

* 3、在Object类中定义的方法，在所有类中都可以使用。
	 
> 1)比较两个对象引用的值是否相等（比较哈希地址）
```
public boolean equals(Object obj)

比较两个对象引用的值是否相等（比较地址）。指出调用该方法的对象是否与obj对象相等。即地址是否相等。
```

> 2)返回十进制整数，唯一标识一个对象
```
public int hashCode()

该方法返回对象的哈希码，哈希码是一个代表对象的十六进制整数，比作对象的身份证号。在程序运行期间，每次

调用同一个对象的hashCode()返回的哈希码必定相同，但是多次执行同一个程序，

程序的一次执行和下一次执行期间同一个对象的哈希码不一定相同。

实际上默认的哈希码是将对象的内存地址通过某种转换得到的，所以不同对象会有不同的哈希码。
```

> 3)返回  类名@hashcode
```
public String toString()

返回  类名@hashcode ；事实上返回这样的字符串没有什么实际的意义。一般子类都会覆盖该方法，让它返回有意义的文本。
```

* equals()方法判断相等

* 理解equals()方法和==运算符的区别是非常重要的。
> 默认情况下（即没有被重写时）equals()只能比较引用类型，"=="既能比较引用类型又能比较基本类型。
> equals()方法从Object类继承，即比较对象引用的值
> 一般都被子类方法覆盖，不再比较引用的值
* "=="运算符:
> 比较基本数据类型：相当于算术等号
> 比较引用数据类型：比较引用的值，不能被覆盖。

* 通常情况，子类要重写equals( )，改变它的含义。所以有的类中equals( )是比较地址，有的类中该方法就不比较地址，具体的，就看子类新定义的该方法的规定。看看包装类中的equals()方法？
* 在java中有个规定：如果equals( )返回两个对象是相等的，那这两个对象上调用hashCode( )返回的整数必须相等。否则在使用Hash类型集合时就会产生错误。
>* 注意：覆盖equals( )方法同时，还要记得覆盖hashCode( ）方法。需要说明，如果equals( )返回两个对象不等，它们的hashCode( )也可以返回相同的整数。但是最好让它们的hashCode( )返回不同的整数，这有利于提高Hash类型集合的性能。

* 1、重写equals方法时，一定要重写hashcode（）方法吗？
> hashcode的调用的条件：
>> 想往map里面放一个类作为map的键值，这个类又是自己设计的；
>> 虽然类不是自己写的，但是你修改了这个类的equals方法；
* 2、如果满足上述调用条件，就要注意重写hashcode方法。 这样 当你往map里放值得时候，系统会调用这个对象的.hashcode()方法来生成相应的hash值，来映射相应的对象。 
> 如果同一个类的两个对象的属性值相等，那么他们的hashcode一定相等吗？ 
这个要看你具体如何实现你的hashcode，如果你希望他们的值一样hashcode也一样，你就可以这样实现。 但是hashcode的实现，一般要满足几个特征，比如 自反性，传递性什么的。 


#### 包装类
* Everything is object.
> Java编程语言不把基本数据类型看作对象。Java 编程语言提供包装类来将基本数据类型看作对象。
> 在功能上包装类能够完成数据类型之间（除boolean）的相互转换，尤其是基本数据类型和String类型的转换。
> 包装类中包含了对应基本数据类型的值，封装了String和基本数据类型之间相互转换的方法，还有一些处理这些基本数据类型时非常有用的属性和方法

* 基本数据类型和对应包装类

数据类型|包装类
:--|:--
boolean|Boolean
byte|Byte
char|Char
double|Double
float|Float
int|Int
long|Long
short|Short

* 包装类常用方法和属性

类型|最大值|最小值
:--|:--|:--|
byte|Byte.MAX_VALUE  &nbsp;&nbsp;&nbsp;  127|Byte.MIN_VALUE  &nbsp;&nbsp;&nbsp;  -128
short|Short.MAX_VALUE  &nbsp;&nbsp;&nbsp;  32767|Short.MIN_VALUE  &nbsp;&nbsp;&nbsp;  -32767
int|Int.MAX_VALUE  &nbsp;&nbsp;&nbsp;  0x7fffffff|Int.MIN_VALUE  &nbsp;&nbsp;&nbsp;  0x80000000
long|Long.MAX_VALUE  &nbsp;&nbsp;&nbsp;  0x7fffffffffffffffL|Long.MIN_VALUE  &nbsp;&nbsp;&nbsp;  0x8000000000000000L

* 字符串与基本数据类型、包装类型转换图

> * `字符串类型(String)`-----使用包装类构造器valueOf()------->`包装类Wrapper`			
> * `包装类Wrapper`------包装类xxxValue()方法--------->`基本数据类型`	
> * `基本数据类型`---------String类的valueOf方法，用连字符"+"-------->`字符串类型(String)`
> * `基本数据类型`---------包装类通过构造器.valueOf()-------->`包装类Wrapper`
> * `字符串类型(String)`---------包装类的parsexxx(方法)------->`基本数据类型`

```
public static void main(String[] args) {
		//如果忘记包装类型长度，试着输出一下最大值与最小值
		System.out.println(Byte.MAX_VALUE);
		System.out.println(Byte.MIN_VALUE);
		
		System.out.println(Short.MAX_VALUE);
		
		System.out.println(Integer.MIN_VALUE);
		
		System.out.println(Long.MAX_VALUE);
		System.out.println(Long.MIN_VALUE);

		//类型转换
		int a=10;
		Integer a1 = new Integer(a);
		System.out.println(a1);
		
		Integer a2 = new Integer("9999");
		//Integer 的valueof 方法可以将其他数据类型    转换为自己的Integer数据类型
		Integer a4 = Integer.valueOf("99");
		System.out.println(a4);
		
		//Integer的intValue()或者是longValue方法可以转换为  将自己转换为对应的数据类型
		int a6 = a2.intValue();
		long a7 = a2.longValue();
		System.out.println(a6+",,,,"+a7);

		//
		int b1 = 10;
		/**
		 * Integer b2=b1;
		 * 从基本数据类型   直接转换为包装数据类型  叫做自动装箱
		 * 
		 * int b3=b2;
		 * 从包装数据类型   直接转换为基本数据类型   叫做自动拆箱
		 */
		Integer b2=b1;
		int b3=b2;
	
	}
```
#### String字符串
#### Math
#### Date

---
### 集合类

#### 链表
















  
  
  
  
  
  
  
  
  
  
  


