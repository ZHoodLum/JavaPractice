### 数据库知识点

&nbsp;|目录|&nbsp;
:-|:------------------:|:--:
1|---------------------------------------------|[限定查询](#限定查询)
||
2|---------------------------------------------|[单行函数](#单行函数)
||
3|---------------------------------------------|[多表查询](#多表查询)
||
4|---------------------------------------------|[数据库操作](#数据库操作)
||
5|---------------------------------------------|[复杂查询](#复杂查询)



---
---

### 限定查询

* 简单查询 select [DISTINCT] *| 字段[别名] from 表明[别名] where 条件(S)

在where子句之后可以增加多个条件，

常见的条件基本关系运算：> 、 >= 、 < 、<= 、 !=( <> ) 、 not、between and 、 like 、in、 is null、 and 、or；

关系运算符： > 、 >= 、 < 、<= 、 !=( <> ) 、 not

        select * from emp where sal>1500;
        
范围运算符：between and
        1）使用between and 求反  在字段条件前加  not  ：
            范例： //查询工资在1530到3000之间员工信息
                select * from emp where not sal between 1530 and 3000; 

        2）同时between and 也可以用于日期格式 ，要求日期要用字符串格式 ： 
            范例：//查询 入职日期在1981-1-1到1981-12-31之间的员工信息
                select * from emp where hiredate between '1-1月-1981' and '31-12月-1981';
                
判断是否为空： is( not ) null
        范例：//查询奖金的员工信息
             select * from emp where comm is not null;
             
指定范围的判断：In操作符，是指定一个查询范围； 其中 not in 指的是不再这个范围内。

        范例： //查询员工信息   编号是 7363、7566、7799
            select * from emp where empno=7963 or empno=7566 or empno= 7799;
            select * from emp where empno in(7363,7566,7799);
            select * from emp where empno not  in(7363,7566,7799);

  注意：关于not  in问题
  
  如果现在使用的是not  in操作符，如果查询范围之中有了null,则不会有任何查询结果返回；如果NOT In 中 出现了NUll 则表示就是查询全部数据。

---

* 模糊查询：LIKE子句：提供了模糊查询的查找操作。例如：某些程序出现的搜索操作，都属于LIKE子句的实现，但是必须提醒，搜索引擎上的查询不是LIKE查询。

     LIKE匹配字符：     匹配单个字符：“   _  ”;            匹配任意多个字符： “ % ”；

            范例：要求查询雇员姓名以字母A开头的全部雇员信息
                select * from emp where ename like 'A%';

            范例： 要求查询雇员姓名第二个字母为A的雇员信息
                select * from emp where ename like '_A%';

            范例： 要求查询雇员姓名带有字母为A的雇员信息
                select * from emp where ename like '%A%';

            范例：可以使用NOT操作符进行求反操作：
                select * from emp where ename not like '%A%';

            注意：对于LIKE子句，不一定只在字符串数据上使用，可以在任意字段上使用；
                   如果在模糊查询上不设置任何查询关键字的话（%%），则表示查询全部记录；这一特带你帮助用户介乎很多代码
                范例：select * from emp where ename  like '%1%' or  hiredate LIKE '%1%' or sal LIKE '%1%';
---

* 数据的排序（重点）

        1）当数据返回结果后，所有数据的默认情况下是按照雇员编号进行排序的。
        
        2）使用ORDER BY 子句指定所需要的排序的操作列。
        
        3）格式：
        
        select [disinct] *|字段[别名] from 表名称[别名] where 条件 [order by 字段 [ASC|DESC ] [字段 [ASC|DESC],]];

        4）order by 子句是写在所有sql语句最后的内容。
        
        
### 复杂查询

范例1：列出至少有一个员工的所有部门编号、名称，并统计 出这些部门的平均工资、最低工资、最高工资。

思路：
* 确定所需要的数据表；
>* emp表：查询员工数量；
>* dept表：部门名称；
>* emp表：统计信息

* 确定已知的关联字段；
>* emp.deptno=dept.deptno;
>* 

* 第一步：找出至少有一个员工的部门编号：
```
select deptno,count(empno)
from emp
group by deptno
having count(empno)>1;
```

* 第二步：找出部门名称，肯定用部门表，现在的数据量较小，所有可以采用多字段分组查询：
```

select d.deptno,d.dname,count(empno)
from emp e,dept d
where e.deptno=d.deptno
group by e.deptno,d.ename
having count(e.empno)>1;
```

* 第三步：整理得：
```
select d.deptno,d.dname,count(empno)，avg(sal),min(sal),max(sal)
from emp e,dept d
where e.deptno=d.deptno
group by e.deptno,d.ename
having count(e.empno)>1;
```

---

范例2：列出工资比“SMITH”或者“ALLEN” 多的所有员工的编号、姓名、部门名称、及其领导姓名

思路：
* 确定所需要的数据表；
>* emp表：查询出SMITH或ALLEN工资；
>* emp表：最终的显示需要编号、姓名；
>* emp表：领导人的姓名，自身关联；
>* dept表：部门名称；

* 确定已知的关联字段；
>* 雇员和领导：emp.deptno=dept.deptno;
>* 雇员和领导：emp.mgr = memp.empno;

* 第一步：找出SIMTH或ALLEN的工资
```
select sal
from emp
where ename in('SMITH','ALLEN');
```

* 第二步：以上的查询返回的多行单列的记录，按照子查询的要求再where 子句中写合适，这个时候将上面的查询作为子查询，继续查询符合要求的员工编号，姓名
```
select e.empno,e.ename
from  emp e
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'));
```

* 第三步：查询部门名称，引入部门表，消除笛卡尔积的条件```

```
select e.empno,e.ename,d.dname
from  emp e,dept d
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'))
ande.deptno=d.deptno;
```

* 第四步：查询领导信息，需要emp表自身关联
```
select e.empno,e.ename,d.dname
from  emp e,dept d,emp m
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'))
and e.deptno=d.deptno
and e.mgr=m.empno;
```

---

范例3：列出所有员工的编号、姓名及其直接上级的编号、姓名，显示结果按领导年工资降序排列。

思路：
* 确定所需要的数据表；
>* emp表：查询员工编号、姓名；
>* emp表：查询领导编号、姓名年薪；

* 确定已知的关联字段；
>* 雇员和领导：emp.mgr = memp.empno;

* 第一步：
```
select e.empno,e.ename,m.empno,m.ename,(m.sal+nvl(m.comm,0))*12 incomm
from emp e,emp m
where e.mgr=m.empno(+)
order by incomm desc;
```


### 总结：

* 多表查询：在进行查询语句编写的时候，一定要确定所需要关联的数据表，而且只是表的关联查询，就一定会存在`笛卡尔积`的问题，使用关联字段可以消除笛卡尔积问题。
* 再多表查询的时候要考虑到左右连接问题，`oracle之外的数据库可以使用SQL：1999语法控制左右连接`；
* 所有统计函数适用于进行数据统计操作的，而统计要在分组中进行（或者单独使用），分组使用`GROUP BY`子句，是在某一列上存在`重复数据`的时候才使用`分组操作`，而分组后的而过滤使用`having`字句完成的，所有的分组函数可以嵌套，但是嵌套智斗的分组函数之中不能有其他的查询字段，包括分组字段。
* 子查询“结合限定查询、多表查询、分组统计查询完成各种复杂查询操作；子查询一般在where和from之后出现较多；
* 数据库的更新操作一定要受到事务控制，事务的两个命令：commit、rollback,每一个连接到数据库上的用户都是用一个session表示。

* 数据表的分页查询显示依靠在rownum伪列，在这个以后的开发之中必定100%要使用。






        
        
