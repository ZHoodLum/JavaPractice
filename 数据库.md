### 数据库知识点

[限定查询](#限定查询)

[单行函数](#单行函数)

[多表查询](#多表查询)

[数据库操作](#数据库操作)




---
---

### 限定查询

* 简单查询 select [DISTINCT] *| 字段[别名] from 表明[别名] where 条件(S)

在where子句之后可以增加多个条件，

常见的条件基本关系运算：> 、 >= 、 < 、<= 、 !=( <> ) 、 not、between and 、 like 、in、 is null、 and 、or；

关系运算符： > 、 >= 、 < 、<= 、 !=( <> ) 、 not

        select * from emp where sal>1500;
        
范围运算符：between and
        1）使用between and 求反  在字段条件前加  not  ：
            范例： //查询工资在1530到3000之间员工信息
                select * from emp where not sal between 1530 and 3000; 

        2）同时between and 也可以用于日期格式 ，要求日期要用字符串格式 ： 
            范例：//查询 入职日期在1981-1-1到1981-12-31之间的员工信息
                select * from emp where hiredate between '1-1月-1981' and '31-12月-1981';
                
判断是否为空： is( not ) null
        范例：//查询奖金的员工信息
             select * from emp where comm is not null;
             
指定范围的判断：In操作符，是指定一个查询范围； 其中 not in 指的是不再这个范围内。

        范例： //查询员工信息   编号是 7363、7566、7799
            select * from emp where empno=7963 or empno=7566 or empno= 7799;
            select * from emp where empno in(7363,7566,7799);
            select * from emp where empno not  in(7363,7566,7799);

  注意：关于not  in问题
  
  如果现在使用的是not  in操作符，如果查询范围之中有了null,则不会有任何查询结果返回；如果NOT In 中 出现了NUll 则表示就是查询全部数据。

---

* 模糊查询：LIKE子句：提供了模糊查询的查找操作。例如：某些程序出现的搜索操作，都属于LIKE子句的实现，但是必须提醒，搜索引擎上的查询不是LIKE查询。

     LIKE匹配字符：     匹配单个字符：“   _  ”;            匹配任意多个字符： “ % ”；

            范例：要求查询雇员姓名以字母A开头的全部雇员信息
                select * from emp where ename like 'A%';

            范例： 要求查询雇员姓名第二个字母为A的雇员信息
                select * from emp where ename like '_A%';

            范例： 要求查询雇员姓名带有字母为A的雇员信息
                select * from emp where ename like '%A%';

            范例：可以使用NOT操作符进行求反操作：
                select * from emp where ename not like '%A%';

            注意：对于LIKE子句，不一定只在字符串数据上使用，可以在任意字段上使用；
                   如果在模糊查询上不设置任何查询关键字的话（%%），则表示查询全部记录；这一特带你帮助用户介乎很多代码
                范例：select * from emp where ename  like '%1%' or  hiredate LIKE '%1%' or sal LIKE '%1%';
---

* 数据的排序（重点）

        1）当数据返回结果后，所有数据的默认情况下是按照雇员编号进行排序的。
        
        2）使用ORDER BY 子句指定所需要的排序的操作列。
        
        3）格式：
        
        select [disinct] *|字段[别名] from 表名称[别名] where 条件 [order by 字段 [ASC|DESC ] [字段 [ASC|DESC],]];

        4）order by 子句是写在所有sql语句最后的内容，说明如下：
            排序的时候可以指定多个排序字段
            排序方式有两种 ： ASC（升序，默认）    DCSC(降序，由大到小)

                范例：select * from emp order by sal ASC        
                          select * from emp order by sal DESC
                范例：要求查询出所有雇员信息，工资由高到低，如果工资相同，则按照雇佣日期有早到晚排序
                          select  * from emp order by sal DESC,hiredate ASC;
 
---

### 单行函数
（重点）
每个数据库都支持SQL语句的，但是每个数据库有自己所支持的操作函数，这就是单行函数。
单行函数主要分为五类：字符函数、数字函数、日期函数、转换函数、通用函数。

#### 字符函数：对字符串进行操作。

1）UPPER（字符串|列）：将输入的字符串变为大写返回；

                作用：用户输入数据的时候，他不会关心大小写的，所以这个时候使用UPPER，
                    范例：select  * from emp where ename=UPPER('simth');
                       -- 这里的‘&’的操作属于替代变量内容，不做重点。
                    范例：select  * from emp where ename=UPPER('&str');
2）LOWER（字符串|列）：将输入的字符串变为小写返回；

                    范例：select  LOWER(ename) from emp;
3）INITCAP（字符串|列）：开头首字母大写；

                    范例：select INITCAP(ename) from emp;
4）LENGTH(字符床|列)：求出字符串的长度；

                    范例： select  LENGTH(ename) from emp;
5）REPLACE(字符串|列)：进行替换； 格式： REPLACE(替换列（内容）,’替换前’,’替换后’)

                    范例： select REPLACE(ename,'A','_') from emp;
6）SUBSTR（字符串|列，开始点，结束点）：字符串的截取。

                  SUBSTR（字符串|列，开始点）    表示从开始一直到结束点；
                  SUBSTR（字符串|列，开始点，结束点）  表示从开始一直到结束点，截取部分内容
                  设置负数，表示从后指定字符串位置

                       范例 select ename,SUBSTR(ename,1,3) from emp;
                       范例：截取字符串后三位长度
                               select ename,SUBSTR(ename,-3) from emp;
面试题：请问：SUBSTR(函数截取的时候是从下标 0 开始的还是 1 开始的？
1）在oracle数据库中 ，substr（）函数从1或1开始都是一样的。
2）substr也可以设置为负数，表示指定从后面指定字符串位置的。

---

#### 数字函数

1）round(数字|列 [可选的保留小数位数] )：四舍五入操作；

                范例：select round( 903.5222 ) from dual; ------------>904
                范例：select round( 903.5434 , 2 ) from dual; ------------>904.54
2）trunc(数字|列 [可选的保留小数位数] )：舍弃指定位置的内容；

                范例：select trunc( 903.555 ) from dual; ------------>903
                范例：select trunc( 903.545 , 2 ) from dual; ------------>903.54
3）mod(数字1，数字2)：取模，取余数。

                范例：select mod( 10,3 ) from dual; ------------>1
以上的三个重要函数，在JAVA中也会有相匹配的内容。

---

#### 日期函数:

1）sysdate取得当前日期。

                 范例：select sysydate from dual;------->18-8月-2018
2）日期 + 数字 = 日期：表示若干天后的日期；

                 范例：select sysydate +300 from dual;------->10-6月-2019
3）日期 - 数字 = 日期：表示若干天前的日期；

4）日期 - 日期 = 数组；表示日期间的天数，但肯定是大日期-小日期；

             范例：select ename,hiredate,sysdate-hiredate from emp;--------------->11198.6925等等诸多数据。

在很多变成语言当中，会提出一种概念，日期可以通过数组表示出来。除了以上的三个公式之外，还有四个操作函数：
1.1）last_day(日期)：求出指定日期的最后一天；

                         范例：select last_day(sysdate) from dual;
1.2）next_day(日期，星期数)：求出下一个指定星期X的日期；

                         范例：select  next_day(sysdate,'星期一') from dual;
1.3）add_months(日期，数字)：求出若干月后的日期；

                         范例：select add_months(sysdate,4) from dual;
1.4）months_between(日期1，日期2)：求出两个月之间所经历的月份。

                         范例：select months_between(sysdate,hiredate) from dual;
                        范例：select trunc(months_between(sysdate,hiredate)) from dual;

注意：开发过程中，建议使用以上函数，可以避免闰年的问题！！！

---

#### 转换函数（核心）

     数字（number）、字符串（varchar）、日期（date），转换函数主要是将这几种数据间的相互转换操作，一共有三种转换函数：
1）to_char(字符串|列 ， 格式字符串)：将日期或者数字转换为字符串显示；

         范例：select sysdate from dual;----------->18-2-1963           日-月-年，不符合正常思维。

         to_char 格式化并定义日期格式：年-yyyy   月-mm  日-dd     hh   时  :   mi   分  :  ss  秒
         范例：select to_char(sysdate,'yyyy-MM-dd') from dual;----------->2018-2-2

         使用to_char(0函数之后，所有内容都是字符串形式，不再是之前的DATE数据，to_char(0函数可以用于数字的格式化上。 
         其中数字9表示每一位数字中的概念，而不是数字9的概念；
         范例：select to_char(9895949494,'999,999,999,999') from dual;------>    9,895,949,494

         其中  L 表示“Locale”含义，表示货币符号￥。
         范例：select to_char(9895949494,'L999,999,999,999') from dual;------>  ￥9,895,949,494
2）to_date(字符串|列 ， 格式字符串)：将字符串转换为DATE数据显示；

     一般在更新数据库中使用；
         范例：select to_date('1996-08-08','yyyy-MM-dd') from dual;----------->1996/8/8
3）to_number(字符串)：将字符串转换为数字显示。但是oracle比较只能，基本不用。

         范例：select to_number('1') + to_number('2') from dual;------>3
         
---

#### 通用函数（核心）

通用函数主要是由两个：NVL()、DECODE(),属于Oracle数据库的特色

1）NVL（）函数，处理Null：

         范例：要求查询每个雇员的全部奖金
                      select ename,sal,comm,(sal+comm)*12 from emp; 

     这个时候由雇员的年薪就变成了bull,而造成这种问题的 关键是在于comm字段上的null,
 那么解决这个问题，就必须作一种处理，将null变为0，而这个就是NVL（）函数：
       范例：select ename,sal,comm,(sal+nvl(comm,0))*12 from emp; 
2）DECODE()函数：多数值判断；这个是oracle数据库最具有特点的函数，要求记住。

    decode()函数非常类似于程序中的if else语句，唯一不同的是decode（）函数判断的是数值，为不是逻辑条件。

       范例：要求显示全部雇员的职位，但是这些职位要求替代为中文显示。
                CLERK:办事员
                SALESMAN:销售
                MANAGER:经理
                ANALYST:分析员
                PRESIDENT:总裁
      这种情况肯定是进行判断，所以这个时候就要使用decode()函数：
      语法：  decode(数值|列 ，判断值1，显示值1，判断值2，显示值2，判断值3，显示值3.........）
            select empno,ename,job,decode(job,'CLERK','办事员','SALESMAN','销售') from emp;

---

### 多表查询
（重点）
* 格式：select *|列 [列名] ....... from 表名 [ 别名]，表名[别名] where 条件；
```
范例：select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;
查询表中的数据量：
范例：select count(*) from emp;
```

* 经验所得: 到公司，别以上来就查询数据信息，数据信息上万条，数据量较大，不要去直接查询表信息，先看看由多少条数据：
```
重点范例：select count(*) from emp;
```
 
* 笛卡尔积：表示多表数据乘积的意思，这种情况是我们不愿意看到的。
```
范例：select * from emp,dept;

所以：解决笛卡尔积办法,使用多表连接查询，加上限制条件。
范例：select * from emp,dept where emp.deptno=dept.deptno;
```

>* 数查询结果消除了笛卡尔积，但是只属于显示上的显出，真正的笛卡尔积依然存在，因为数据库的操作机制属于逐行
进行数据判断，现在假设两个表的数据量很大，在这种情况下使用多表查询的性能，查询结果会很慢或者不显示。
多表查询性能(前提是数据量大！上万条或更多！！！），数据量小的话可以使用（几千条数据！！！）。
开发过程中，尽量避免多表查询，可以把数据方法一个表中，单表查询速度快。
```
但是以上范例程序中，出现了表名过程，需要为表名 建立一个别名去简化。

范例：select * from emp e , dept d where e.deptno=d.deptno;
```


* 思考步骤：
>* 1)查询所需要的表：
>> emp表( 雇员); 取得雇员姓名、职位、领导编号。
>> emp表( 领导 );取得雇员的姓名（领导姓名）。

>* 2)确定关联字段：雇员领导编号 = 领导（雇员）的雇员编号
```
范例：select e.ename ,e.job,m.ename from emp e,emp m where e.mgr=m.empno;
其中查询结果中没有King的记录，因为KING没有领导，他是老大，而解决这个问题，就涉及到左、右连接问题。
```

```
* 范例：查询每个雇员姓名，编号，基本工资，领导姓名，部门名称及位置。
>* 1)查询所需要的表：
emp表( 雇员); 取得雇员姓名、职位、领导编号，基本工资。
emp表( 领导 );取得雇员的姓名（领导姓名）。
dept表：部门名称及位置。

>* 2)确定关联字段：
雇员和部门： emp.deptno=dept.deptno
雇员和领导： emp.mgr = memp.empno

select e.empno,e.ename,e.sal,e.job,m.ename from emp e,emp m ,dept d
where e.mgr=m.empno and e.deptno=d.deptno;左右连接：关于左右连接，指的是查询判断条件的参考方向。

范例：select * from emo e,dept d where e.deptno(+) =d.deptno;
```

* 1）使用（+）用于左右连接的更改

>*  (+)= ：放在了等号的左边，表示右连接；

>*  = (+)：放在了等号的右边，表示左连接；

* 但是我们不用刻意去区分左右，知识根据查询结果去定，如果发现查询结果没有我们想要的信息，就可以此符号进行更改连接方向，这个是oracle数据库独有的特性，其他数据库不具备。

---

### 需要使用SQL：1999语法：
 
* 1、交叉连接：（cross join）:用于产生笛卡尔积。
```
select * from emp cross join dept;

注：笛卡尔积本身并不属于无用的内容，在某些情况下还需要使用的。
```

* 2、自然连接：natural join:用于消除笛卡尔积。
```
select * from emp natural join dept;

注：但是并不是所有字段都是关联字段，设置关联字段需要通过约束指定。
```

* 3、 join………… using子句：用户自己指定一个消除笛卡尔积的关联字段。
```
select * from emp join dept using(deptno);
```

* 4、join…….on子句：用户可以自己指定一个消除笛卡尔积的关联条件。
```
select * from emp join dept on(emp.deptno=dept.deptno);
```

* 5、连接方向的改变。

>* 左(外)连接：left outer join….on;
>* 右(外)连接：right outer join….on;
>* 全(外)连接：full outer join….on;———-→把两张表中没有的数据全部显示。

注：在oracle之外的数据库都是用以上的SQL：1999语法操作，所以这个语法还必须会一些。多表查询肯定不高，早大量数据中才会发现，在开发过程中，能不用则不用。

---

### 统计函数（重点）
* 常用的统计函数：count()、avg()、sum()、max()、min().

>* count(): 查询表中的数据记录；

>* avg(): 求出平均值；

>* sum(): 求和；

>* max(): 求出最大值；

>* min(): 求出最小值；

```
范例：统计出公司所有雇员，每个月支付的平均工资及总工资,最大工资，最小工资
select count(*),sum(sal),avg(sal),min(sal),max(sal) from emp;
	* 
注意：count()函数查询的表中即使没有数据记录，结果也会返回数据，返回数据值是：0；如果使用其他函数，返回数据会为null,如果使用count()函数，无论什么情况下，都会返回数据值。
```

---

### 分组查询（重点）

* 什么情况下会进行分组，信息保存在数据库之中，那么在数据的某一列上肯定会存在重复的内容，例如：性别分组（男或女），等等
所以在分组中有一个不成文的规定，当数据重复的时候分组才有意义，因为一个人也可以一组（没有意义）。
而如果要想分组，需要使用子句group by子句进行使用。

* 格式：
```
select distinct *|列，[分组字段1],[分组字段2]....
from 表名 [别名]
where 条件
group by 分组字段1，分组字段2.......
order by 排序字段 ASC|DESC [排序字段 ASC|DESC]；
注意：group by 必须写在order by字段前面。order by必须写在SQL语句最后面。
```

* 范例：
```
select deptno,count(empno),avg(sal) from emp group by deptno;
查询出领取佣金和不领取佣金的雇员人数及平均工资
select comm,count(empno),avg(sal) from emp group by comm;
```
* 注意：
>* 1）分组函数可以在没有分组的情况下单独使用，但是不能出现其他的查询字段。

用法|说明
:--|:--
分组函数可以单独使用|select count(empno) from emp;
错误的使用，出现了其他字段|select ename,count(empno) from emp;

>* 2）如果现在要进行分组的话，则select子句之后，只能出现分组的字段和统计函数，其他字段不能出现。
>* 3）分组函数允许嵌套。
>* 4）在where子句中不能使用分组函数。
>* 5）如果在对分组后的数据进行过滤，这时候就要使用：`having`

```
查询出每个部门的名称，部门人数，位置，平均工资。
select d.deptno,d.dname,d.loc,count(emp),nvl(avg(e.sal),0)
from emp e,dept d
where d.deptno=e.deptno(+)
group by d.dname,d.deptno,d.loc;
having avg(sal)>2800;
```
* 注意：
>* 1）对数据进行分组，表可以是实体表（emp,dept），也可以是虚拟表（查询的出来的表），只要是有重复内容，就可以进行分组
>* 2）where : 是在执行group by操作之前进行的过滤，表示从全部数据中选出部分的数据；在where不能使用统计函数
>* 3）having : 是在group by 分组之后的再次过滤，可以在having使用统计函数。


---

### 数据库操作

DML语法中，除了查询之外还有数据库的更新操作，数据的更新操作：增加、修改、删除数据。

#### 表的赋值

##### 格式：表的赋值：create table [复制产生的表的表名]  as  [查到这个表的信息并复制（select * from emp）];
* 注意：这个语法是oracle中支持的操作，其他数据库不一样。

#### 数据的增加

##### 格式：insert into 表名(字段1，字段2.......) values(值1，值2............);
如果想要增加数据，则一下几种数据类型要分别处理：
* 增加数字：直接编写数字；
* 增加字符串：使用单引号 ` ' `
* 增加DATE数据：
>* 第一种：可以按照已有的字符串格式编写字符串。例如：18-2月-1998;
>* 第二种：利用to_date()函数将字符串变为date数据。在添加时间字段中这样写：to_date('1995-02-14','yyyy-mm-dd')；
>* 第三种：如果设置的时间为当前时间，则使用sysdate。

#### 数据的更新

##### 格式：update 表明 set 更新字段1=更新值1，更新字段2=更新值2...................... where 条件（s）;
```
所有人的工资上涨到7500；
update myemp  set sal=5000*1.5;
```
* 注意：如果更新的时候不加更新条件，则意味着更新全部信息，但是这种做法是不可取的，如果表中的数据量较大的话，这种更新会耗费很多的时间，性能降低。(3000-5000条数据就别这么干了，信息量太大！！！)

#### 数据的删除

##### 删除表中的某一条数据
* 格式：delete from [表名] where [条件]；

##### 删除表中的数据：
* 格式：delete from [表名] 

---

### 事务处理
#### 事务(Transaction)概念
* 事务：也称工作单元，是由一个或多个SQL语句所组成的操作序列，这些SQL语句作为一个完整的工作单元，要么全部执行成功，要么全部执行失败。在数据库中，通过事务来保证数据的一致性。



* 事务处理语言：Transaction Process Language ,简称TPL，主要用来对组成事务的DML语句的操作结果进行确认或取消。确认也就是使DML操作生效，使用提交(COMMIT)命令实现；取消也就是使DML操作失效，使用回滚(ROLLBACK)命令实现。

* 通过事务的使用，能防止数据库中出现数据不一致现象。如两个银行账户进行转账，涉及到两条更新操作，这两条更新操作只允许全部成功或失败，否则数据会出现不一致的现象

---

#### 事务特征可用四个字母的缩写表示：即ACID

* 原子性（Atomicity）

>* 事务就像“原子”一样，不可被分割，组成事务的DML操作语句要么全成功，要么全失败，不可能出现部分成功部分失败的情况。



* 一致性（Consistency）

>* 一旦事务完成，不管是成功的，还是失败的，整个系统处于数据一致的状态。



* 隔离性（Isolation）

>* 一个事务的执行不会被另一个事务所干扰。比如两个人同时从一个账户从取钱，通过事务的隔离性确保账户余额的正确性。



* 持久性（Durability）

>* 也称为永久性，指事务一旦提交，对数据的改变就是永久的，不可以再被回滚。



---

#### 事务结束
##### 显示结束
* 提交(COMMIT)：使用COMMIT命令实现，以成功的方式结束事务，组成事务的DML语句操作全部生效。

* 回滚(ROLLBACK)：使用ROLLBACK命令实现，以失败的方式结束事务，组成事务的DML语句操作全部被取消。

```

update emp set sal=9800 where empno=7799;

rollback;

commit;

```

---

##### 隐式结束

* 隐式提交：当下列任意一种情况发生时，会发生隐式提交

>* 执行一个DDL(CREATE、ALTER、DROP、TRUNCATE、RENAME）语句；

>* 执行一个DCL(GRANT、REVOKE)语句；

>* 从SQL*Plus正常退出（即使用EXIT或QUIT命令退出）；



* 隐式回滚：当下列任意一种情况发生时，会发生隐式回滚

>* 从SQL*Plus中强行退出

>* 客户端连接到服务器端异常中断

>* 系统崩溃

---
* 注意：所有事物处理操作都是针对每一个session进行的，在oracle之中，把每一个连接到数据库上的用户都称为一个session，每一个session之间彼此独立，不会有任何通讯，任何一个session独享自己的事务控制，主要使用两个命令：
```
* commit;--同时提交
* rollback;--同时失败
*  事务的回滚：rollback;更新操作回到原点；
*  事务的提交：commit; 真正发出的更新操作，一旦提交后无法更改。
*  某一个session在更新数据表的时候还没有提交事务，其他session是无法更新的，必须等待之前的session提交后才可以操作。
* 这个问题从大的方面来讲：称为死锁，但是在oracle之中死锁有很多种类，这些与开发者没有太大的关系，是由DBA负责的。
```

---

### 数据伪劣
#### rownum(核心重点)
* rownum在单词的含义上讲表示行号，但在实际意义上rownum为每一条显示的记录都会自动的随着查询生成行号。

```
范例1：此时的rownum行号并不是固定的：
select rownum,empno,ename from emp where deptno = 30;

范例2：每次动态的重新生成，可以实现数据的部分显示：
select rownum,empno,ename from emp where rownum <= 5;

范例3：显示数据的6-10条数据：
`思路：先查询前10条数据，之后再显示后5条数据，这时候要依靠子查询。`
select * from `(select rownum,empno,ename from emp where rownum <= 10)` from emp;

范例4：每页显示5条数据。
* 当前所在页数 cunentPage  为1；
* 每页显示长度：lineSize  为5；
select * from `(select rownum rn,empno,ename from emp where rownum <=5)` temp where temp.rn>0;

范例5：显示中间5条数据。
* 当前所在页数 cunentPage  为2；
* 每页显示长度：lineSize  为5；
select * from `(select rownum rn,empno,ename from emp where rownum <=10)` temp where temp.rn>5;

```

---

#### rowid(了解)
* rowid 表示的是每一行数据保存的物理地址的编号。
每一条记录的 rowid 不会重复的。 即便是表中的所有列的数据内容都重复了，rowid也不会重复。

* 面试题：请删除表中的重复记录。

```
思路一：先按照查询方式。首先找到所有重复数据，按照部门名称及位置进行分组，之后统计个数，如果个数大于1，则表示重复。
selectdname,loc,min(rowid)
from dept
group by dname,loc
having count(deptno) >1
```

* `数据插入的数据早，rowid就小`。所以下一步就是必须确定不能删除的rowid,去掉之前的限制(count() > 1),表示按照部门名称及位置分组，去除每一个最小的rowid。

```
selectdname,loc,min(rowid)
from dept
group by dname,loc；
```

* 上面的这个语句，是最开始插入的语句，所以是不删除的，下面执行delete语句操作：

```
delete from dept
where rowid not in(
selectdname,loc,min(rowid)
from dept
group by dname,loc
);
commit;
```
* 此时根据rowid完成的，就是删除重复的数据。

















































