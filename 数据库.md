### Oracle数据库知识点

&nbsp;|目录|&nbsp;
:-|:------------------:|:--:
1|---------------------------------------------|[限定查询](#限定查询)
||
2|---------------------------------------------|[单行函数](#单行函数)
||
3|---------------------------------------------|[多表查询](#多表查询)
||
4|---------------------------------------------|[数据库操作](#数据库操作)
||
5|---------------------------------------------|[复杂查询](#复杂查询)
||
6|---------------------------------------------|[数据库表的使用及管理](#数据库表的使用及管理)
||
7|---------------------------------------------|[视图索引序列](#视图索引序列)


---
---

### 限定查询

* 简单查询 select [DISTINCT] *| 字段[别名] from 表明[别名] where 条件(S)

在where子句之后可以增加多个条件，

常见的条件基本关系运算：> 、 >= 、 < 、<= 、 !=( <> ) 、 not、between and 、 like 、in、 is null、 and 、or；

关系运算符： > 、 >= 、 < 、<= 、 !=( <> ) 、 not

        select * from emp where sal>1500;
        
范围运算符：between and
        1）使用between and 求反  在字段条件前加  not  ：
            范例： //查询工资在1530到3000之间员工信息
                select * from emp where not sal between 1530 and 3000; 

        2）同时between and 也可以用于日期格式 ，要求日期要用字符串格式 ： 
            范例：//查询 入职日期在1981-1-1到1981-12-31之间的员工信息
                select * from emp where hiredate between '1-1月-1981' and '31-12月-1981';
                
判断是否为空： is( not ) null
        范例：//查询奖金的员工信息
             select * from emp where comm is not null;
             
指定范围的判断：In操作符，是指定一个查询范围； 其中 not in 指的是不再这个范围内。

        范例： //查询员工信息   编号是 7363、7566、7799
            select * from emp where empno=7963 or empno=7566 or empno= 7799;
            select * from emp where empno in(7363,7566,7799);
            select * from emp where empno not  in(7363,7566,7799);

  注意：关于not  in问题
  
  如果现在使用的是not  in操作符，如果查询范围之中有了null,则不会有任何查询结果返回；如果NOT In 中 出现了NUll 则表示就是查询全部数据。

---

* 模糊查询：LIKE子句：提供了模糊查询的查找操作。例如：某些程序出现的搜索操作，都属于LIKE子句的实现，但是必须提醒，搜索引擎上的查询不是LIKE查询。

     LIKE匹配字符：     匹配单个字符：“   _  ”;            匹配任意多个字符： “ % ”；

            范例：要求查询雇员姓名以字母A开头的全部雇员信息
                select * from emp where ename like 'A%';

            范例： 要求查询雇员姓名第二个字母为A的雇员信息
                select * from emp where ename like '_A%';

            范例： 要求查询雇员姓名带有字母为A的雇员信息
                select * from emp where ename like '%A%';

            范例：可以使用NOT操作符进行求反操作：
                select * from emp where ename not like '%A%';

            注意：对于LIKE子句，不一定只在字符串数据上使用，可以在任意字段上使用；
                   如果在模糊查询上不设置任何查询关键字的话（%%），则表示查询全部记录；这一特带你帮助用户介乎很多代码
                范例：select * from emp where ename  like '%1%' or  hiredate LIKE '%1%' or sal LIKE '%1%';
---

* 数据的排序（重点）

        1）当数据返回结果后，所有数据的默认情况下是按照雇员编号进行排序的。
        
        2）使用ORDER BY 子句指定所需要的排序的操作列。
        
        3）格式：
        
        select [disinct] *|字段[别名] from 表名称[别名] where 条件 [order by 字段 [ASC|DESC ] [字段 [ASC|DESC],]];

        4）order by 子句是写在所有sql语句最后的内容。
        
        
### 复杂查询

范例1：列出至少有一个员工的所有部门编号、名称，并统计 出这些部门的平均工资、最低工资、最高工资。

思路：
* 确定所需要的数据表；
>* emp表：查询员工数量；
>* dept表：部门名称；
>* emp表：统计信息

* 确定已知的关联字段；
>* emp.deptno=dept.deptno;
>* 

* 第一步：找出至少有一个员工的部门编号：
```
select deptno,count(empno)
from emp
group by deptno
having count(empno)>1;
```

* 第二步：找出部门名称，肯定用部门表，现在的数据量较小，所有可以采用多字段分组查询：
```

select d.deptno,d.dname,count(empno)
from emp e,dept d
where e.deptno=d.deptno
group by e.deptno,d.ename
having count(e.empno)>1;
```

* 第三步：整理得：
```
select d.deptno,d.dname,count(empno)，avg(sal),min(sal),max(sal)
from emp e,dept d
where e.deptno=d.deptno
group by e.deptno,d.ename
having count(e.empno)>1;
```

---

范例2：列出工资比“SMITH”或者“ALLEN” 多的所有员工的编号、姓名、部门名称、及其领导姓名

思路：
* 确定所需要的数据表；
>* emp表：查询出SMITH或ALLEN工资；
>* emp表：最终的显示需要编号、姓名；
>* emp表：领导人的姓名，自身关联；
>* dept表：部门名称；

* 确定已知的关联字段；
>* 雇员和领导：emp.deptno=dept.deptno;
>* 雇员和领导：emp.mgr = memp.empno;

* 第一步：找出SIMTH或ALLEN的工资
```
select sal
from emp
where ename in('SMITH','ALLEN');
```

* 第二步：以上的查询返回的多行单列的记录，按照子查询的要求再where 子句中写合适，这个时候将上面的查询作为子查询，继续查询符合要求的员工编号，姓名
```
select e.empno,e.ename
from  emp e
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'));
```

* 第三步：查询部门名称，引入部门表，消除笛卡尔积的条件```

```
select e.empno,e.ename,d.dname
from  emp e,dept d
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'))
ande.deptno=d.deptno;
```

* 第四步：查询领导信息，需要emp表自身关联
```
select e.empno,e.ename,d.dname
from  emp e,dept d,emp m
where e.sal>all(
                   select sal from emp where ename in('SMITH','ALLEN'))
and e.deptno=d.deptno
and e.mgr=m.empno;
```

---

范例3：列出所有员工的编号、姓名及其直接上级的编号、姓名，显示结果按领导年工资降序排列。

思路：
* 确定所需要的数据表；
>* emp表：查询员工编号、姓名；
>* emp表：查询领导编号、姓名年薪；

* 确定已知的关联字段；
>* 雇员和领导：emp.mgr = memp.empno;

* 第一步：
```
select e.empno,e.ename,m.empno,m.ename,(m.sal+nvl(m.comm,0))*12 incomm
from emp e,emp m
where e.mgr=m.empno(+)
order by incomm desc;
```


### 总结：

* 多表查询：在进行查询语句编写的时候，一定要确定所需要关联的数据表，而且只是表的关联查询，就一定会存在`笛卡尔积`的问题，使用关联字段可以消除笛卡尔积问题。
* 再多表查询的时候要考虑到左右连接问题，`oracle之外的数据库可以使用SQL：1999语法控制左右连接`；
* 所有统计函数适用于进行数据统计操作的，而统计要在分组中进行（或者单独使用），分组使用`GROUP BY`子句，是在某一列上存在`重复数据`的时候才使用`分组操作`，而分组后的而过滤使用`having`字句完成的，所有的分组函数可以嵌套，但是嵌套智斗的分组函数之中不能有其他的查询字段，包括分组字段。
* 子查询“结合限定查询、多表查询、分组统计查询完成各种复杂查询操作；子查询一般在where和from之后出现较多；
* 数据库的更新操作一定要受到事务控制，事务的两个命令：commit、rollback,每一个连接到数据库上的用户都是用一个session表示。

* 数据表的分页查询显示依靠在rownum伪列，在这个以后的开发之中必定100%要使用。


---

### 数据库表的使用及管理
### 表的创建及管理
（重点）

对于数据库而言实际上每一张表都表示一个数据库的对象，而在数据库对象指的就是DDL定义的所有操作，例如：表、视图、索引、序列、约束等等，都属于对象的操作，所有表的建立就是对象的建立，而对象的操作主要分为以下三类语法：

* 创建对象：  create  对象名称..............;
* 删除对象：  drop 对象名称..............;
* 修改对象 ： alter  对象名称..............;

每一张数据表实际上都是有若干个字段组成，而每一个字段都会有其对应的数据类型 ，在oracle数据库中，常用的数据类型有：

No.|数据类型|关键字|描述
:-:|:---:|:---:|:---:
1|字符串|VARCHAR2(n)|其中n表示字符串所能保存的最大长度，基本上保存200个左右的内容
2|整数|NUMBER(n)|表示最多为n的整数，有时候也可以使用int代替
3|小数|NUMBER(n.m)|其中M为小数位，n-m为整数位，有时候也可以使用float代替
4|日期|DATE|存放时间
5|大文本|CLOB|可以存储海量文字（4G），例如存储《三国演义》、《红楼梦》
6|大对象|BLOB|存放二进制数据，电影、mp3、图片

* 注意：一般在开发过程中使用最多的就是：varchar2()、number、date、clob，而对于clob字段一般使用较少，首先blob可以存放4G的二进制数据，但是存放进去之后，一是数据库过于庞大，二是读取不方便。

---

### 数据库表的创建

创建表使用的CREATE语法。
* default  表示该字段默认值           
```
create table(
name varchar2 default '无名氏',
age number(3),
bitthday date
)
```

---

### 数据库表的复制

* 格式：create table 复制表的名字 as  子查询；
```
create table emp2 as select * from emp where deptno = 20;
```


#### 重点范例：要求复制emp表的表结构复制出来，不要数据。
```
思路：写一个永远不会满足的条件即可

create table emp3 as select * from emp where 1=2;

* 划重点：这个只是复制表结构，并不包含里面的数据！！！！！并且，以上语法只是Oracle数据库所支持的操作，
其他数据库会有一些区别！！！！
```

---

### 数据库表的重命名

（了解）

* 在oracle数据库之中，所有数据实际上都是通过数据字典保存的，例如：前面使用的查询语句：
```
select * from tab;
```

* 以上就是一个数据字典，而在Oracle之中，提供了三种类型的而数据字典，最常用的是：dba_、user_，例如：查询一个user_tables数据字典：
```
select * from user_tables;
```

* 也就是说Oracle中的所有数据都是按照文件保存的，也就是说所有内容都会在数据字段中注册，既然这样，所谓的修改表名实际上对Oracle而言就是相当于修改一条数据而已，例如修改表名如下：
```
rename 旧表名称 to 新表名称；
注意：Oracle独有的特性！！！！
```

---

### 数据库表的截断表（了解）

在之前删除数据库操作，使用的是delete操作，但是这种操作本身就有一个特点，即：可以运行事务的回滚，
也就是说删除之后并不会立刻释放数据的资源，如果现在希望释放一张表所占用的全部资源（表空间、索引等等），这时候就可以使用截断表：

截断表是Oracle数据库所特有的！！！！！

```
truncat table 表名；

查看是否已经释放资源；
对事物进行回滚：
rollback;

查看是否还有数据：
select * from 表名称；
```

---

### 数据库表的删除

（了解）

表的删除操作指的是数据库删除操作，使用DROP语句：
```
格式：drop table 表名称;
```
* 注意：但是并没有全部删除干净；在 oracle 10g 的特性中，闪回技术特性！！！！

---

####  闪回技术

* 为了防止用户误删出表操作，专门提供了回收站的功能，用户删除表的默认情况下会在一个回收站之中保存，

而用户也以通过回收站，进行表的恢复操作，所以此技术成为闪回（FLASHBACK）。

```
SHOW  RECYCLEBIN ;
这时候就可以发现所有删除表都在回收站中保存，使用下面的语法进行恢复表操作：

flashback table 表名称  to  before  drop;
```

* 当然也可以直接删除回收站中的一些数据表：
```
purge table 表名称
```

* 清空回收站（重中之重）
```
purge recuclebin;
```

##### 所以说真正删除表操作如下
```
drop table 表名称 purge;
```


##### 注意（划重点）：必须在sql plus或者图形可视化界面中得command窗口下进行闪回操作。记住哈：回收站中有一张tab表，但是我又在数据库中新建了一张表，那么如果从回收站恢复的话，它是不能进行恢复的，有一点，这个一般人想不出来！！！！仔细想想Windows的回收站。！！！

---

### 修改表结构

（了解）
* 表的修改操作，实际上是数据库对象的操作。

* 为表添加列语句

``` 
* 格式：alert table 表名称 add (列名称 数据类型 [default 默认值],
                                                列名称 数据类型 [default 默认值],
                                                列名称 数据类型 [default 默认值]...................
                                                 )；
如果增加的数据列没有默认值，则所有的数据的列的内容都是null，如果增加的列指定了defalut默认值的话，则所有已有的数据列都是设置的默认值
```

---

* 修改表的内部结构

```
* 格式：alert table 表名称 modify (列名称 数据类型 [default 默认值],
                                                列名称 数据类型 [default 默认值],
                                                列名称 数据类型 [default 默认值]...................
                                                 )；
 此语句能不用则不用，
```

---

#### 思考题：现在有一张表：nation表，表中有一个name字段，里面保存四条记录：中国、美国、巴西、荷兰，要求通过查询实现如下操作：
```
* 中国    美国
* 中国    巴西
* 中国    荷兰
* 美国    巴西
* 美国    中国
* 美国    荷兰
............
剩下的以此类推，现在要求建立新的表并完成查询操作；
```

##### 本题目的主要目的并不是在于查询编写上，而是在规范化数据库创建脚本的格式，以后钥匙碰到了类似的要求，首先必须编写一个数据库创建脚本，这个脚本要求如下：

```
1、本文件的文件名称必须是“  *.sql   ”：
2、先删除相应的数据表：
drop table nation purge;

3、编写创建表的语句：
create table nation(
name varchar2(10)
)

4、增加测试数据：
insert into nation(name) values('中国')；
insert into nation(name) values('美国')；
insert into nation(name) values('荷兰')；
insert into nation(name) values('巴西)；

5、提交事务；
commit;
```

##### 执行查询语句；
```
select
from nation n1,nation n2
where n1.name<>n2.name;
```


---

### 约束
（重点）
通过约束完成，约束的主要功能是保证表中的数据合法性，按照约束的分类，一共有五种约束：非空约束唯一约束、主键约束、外键约束、检查约束。

#### 非空约束(NOT NULL):NT
当数据表中的某个字段，不希望设置为null的话，则可以使用not null来指定，对字段进行约束。
```
若字段进行非空约束，插入数据时，没有添加某字段数据，就会报错：
ORA-01400:无法将null 插入("SCOTT","MEMBER","NAME");
本程序中显示出“用户”，“表名称”，“字段” 出现了错误。
``` 

#### 唯一约束(UNIQUE):UK
唯一约束指的是每一个列上的数据不允许重复的。
```
范例1：
create table emp(
    mid number  not null,
    ename varchar2(50) not null,
    email varchar2(50) unique
)
```

##### 如果插入条件违反约束，就会有错误提示：
```
ORA-00001:违反唯一约束 条件（SCOTT.SYS_C005277）;

可是这个时候的错误提示信息并不完善，与之前的非空错误提示相比，因为现在知识给出了一个代号而已，
再定义约束的时候没有为约束指定一个名字，所以系统默认分配了，
而且约束的名字建议格式：“ 约束类型——字段  ”，例如：“UK_email”,指定约束名称使用” constraint “完成。
```

##### 格式：CONSTRAINT 约束名称 UNIQUE (字段名|列名)；
```
范例2：
create table emp(
    mid number  not null,
    ename varchar2(50) not null,
    email varchar2(50),
    constraint UK_email UNIQUE(email);
)
```

##### 如果插入条件违反约束，就会有错误提示：
```
ORA-00001:违反唯一约束 条件（SCOTT.UK_EMAIL）;
这个就明确提示用户约束的错误位置！！！！
```

---

#### 主键约束（Primary Key）
主键约束=非空约束+唯一约束，使用主键约束，不能为null,作为数据的唯一的一个标识出现。

##### 建表时创建约束：
```
范例：
create table tap(
mid number primary key,
name varchar2(23) not null
)
```

##### 建表后添加约束：
格式： constraint 约束名称 primary key (字段名称);
```
范例：
constraint pk_mid primary key (mid);
```

注意：还存在复合主键，但是正常人都不会去设置复合主键，一般只适用id作为表的主键。永远只有一个主键！！！！
```
复合主键就是：存在主键1，主键2，当两个字段的值都相同就会报错
创建：   constraint pk_mid_name primary key (mid,name);
```

---

#### 检查约束（Check）:CK
检查约束指的是为表中的数据增加一些过滤条件。
```
例如：
设置年龄的时候范围是：0-250；
设置性别约束：男，女，中；
```

##### 格式：constraint 约束名称 Check (字段名+限制条件)；
```
constraint ck_sex Check (sex in ('男','女','中'))；
constraint ck_age Check (age between 0 and 250)；
```

---
#### 主外键约束（核心难点）
之前的四种约束都是单张表中进行的，而主外键约束是在两张表中进行的，这两张表是存在父子关系的，即：字表中的某个字段的取值范围由父表所决定的。
```
范例：要求创建两个表，并进行约束限制。

主表：
create table dept (
    deptno number,
    dname varchar2(23),
    loc varchar2(20),
    constraint pk_deptno primary key (deptno)
)

子表
create table emp(
    empno number,
    ename varchar2(25),
    deptno number,'
    constraint pk_empno primary key(empno),
    constraint fk_deptno foreign key(deptno) references dept(deptno)
)

```

##### 此时，知识增加了一个约束，这样一来如果输入的数据有错误，就会提示：

```
ORA-02291:违反了完整约束条件（SCOTT FK_DEPTNO），未找到父项关键字；

```

##### 但是在删除数据的时候，如果主表的数据有对应的子表数据，则无法删除。此时只能先删除子表记录，之后再删除父表记录。（先删除子，再删除父！！！！）

想想啊，这要是开出一个雇员，我还要逐条的将他的信息删除，很麻烦的啊！如果现在希望主表数据显出之后，子表对应的数据也可以删除的话，
就可以再建立外键约束的的时候指定一个级联删除功能，修改数据库创建脚本：
```
范例：编写代码` on delete cascade`，进行级联删除操作。
主表：
create table dept (
    deptno number,
    dname varchar2(23),
    loc varchar2(20),
    constraint pk_deptno primary key (deptno)
)

子表
create table emp(
    empno number,
    ename varchar2(25),
    deptno number,'
    constraint pk_empno primary key(empno),

    constraint fk_deptno foreign key(deptno) references dept(deptno)
    on delete cascade  --设置为级联操作
)
此时由于存在级联删除的操作，所以再主表的数据删除之后，对应的子表数据也都会被同时删除。
```

##### 上述的删除操作太霸道，这简直是弟弟行为啊！！！！！想想怎样才能让他成为我的贴身保镖。删除表的时候，让子表对应的数据设置为null。
```
当主表数据删除后，对应的字表中的数据相关项也希望将其设置为空，而不是删除，

主表：
create table dept (
    deptno number,
    dname varchar2(23),
    loc varchar2(20),
    constraint pk_deptno primary key (deptno)
)

子表
create table emp(
    empno number,
    ename varchar2(25),
    deptno number,'
    constraint pk_empno primary key(empno),

    constraint fk_deptno foreign key(deptno) references dept(deptno)

    on delete   --将表设置为级联操作
    set null       --  当主表数据删除后，子表数据为空值
)

```

#####  那么问题又来了啊，突然有一天，主管让你来删除表，你不可能去数据库中找表之间对应的父子关系把，一张表有上百条子表呢，所有说，没办法筛选，但是啊！！！你用的是Oracle数据库啊，Oracle数据库就比较牛批了，强制删除操作，不再关系约束，不管你有没有儿子。

格式：drop table 表名称 cascade constraint;
```
再删除语句中写上一句：`cascade constraint`,也就是直接删除不再进入回收站中，请再添加一句：`purge`。

范例：delete table emp cascade constraint pruge;
此时，不关心子表是否存在，直接强制删除父表。。人生圆满啊！！！！

注意：其实我想告诉你真正的做法：进行数据库表删除操作的时候，最好先删除子表，之后再删除父表。毕竟没买保险！！！！！
```
#### 总结创建主外键约束表：
```
主表：
create table dept (
    deptno number  primary key,--主键
    dname varchar2(23),
    loc varchar2(20)
)

子表
create table emp(
    empno number primary key,--主键
    ename varchar2(25),
    deptno number references dept(deptno) on delete cascade -- 级联表操作
)

希望你所创建的表是一气呵成的。当然，并不排除产品经理会让你改需求。

产品经理：改需求，要求APP主题颜色随着客户心情变化而变化，必须再上线之前做出来（3天），如果你不配合我去找技术总监。
程序猿：怎么滴，想干一架啊！！！！
干架中.......
开除！！！！！！之后两人又进同一家公司，待续。。。。。。。。
```


---

#### 修改约束
约束本身属于数据库对象，只要是修饰都是用alert指令，修改约束操作有：
```
为表添加约束：
alert table 表名 add constraint 约束名称  约束类型（字段）;
删除表中的约束：
alert table 表名 drop constraint 约束名称;

可是在这五种约束之中，可以发现，如果维护约束，肯定要一个正确的名字才可以，
但是在这五种约束之中，非空约束（not null）作为一个特殊约束的约束无法操作。
约束跟表的结构一样，最好不要修改，表建立的时候一定要将约束定义好。
```

#### 查询约束
再Oracle之中的所有对象都会在 数据字典之中保存，而约束也是一样的，所以如果想知道有哪些约束，可以直接查询user_constraints 数据字典。 

##### 格式：查询user_constraints 数据字典
```
select * from user_constraints;   或 者
select owner,constraint_name,table_name  from user_constraints;
此时的数据字典并不能满足我的需求啊！
```

##### 格式：查询user_cons_columns 数据字典，column_name显示约束的字段名。
```
select * from user_cons_columns; 或者
select owner,constraint_name,table_name,column_name  from user_cons_columns;

发现没，我靠，它串行啊，样式看着很难受，我决定要格式化一下，从新定义这个列表的宽度：
col owner for A15;
col constraint_name for A15;
col table_name for A15;
col column_name for A15;
select owner,constraint_name,table_name,column_name  from user_cons_columns;

可是啊，如果你是一名开发程序猿，不用去关心这些，做好自己的事。这些维护的工作大部分应该由专门的DBA负责而不是作为程序开发的你。
```

---

### 集合
再数学的操作中存在交、差、并、补的概念，再数据查询中也存在此概念，有以下爱一个连接符号：
```
1）union:连接两个查询，相同部分不显示；
select * from emp 
union
select * from emo20;

2）union all:连接两个查询，相同的部分显示；
select * from emp 
union all
select * from emo20;
3）intersect:返回两个查询中相同的部分；
select * from emp 
union
select * from emo20;

4）minus:返回两个查询中的不同部分；
select * from emp 
union
select * from emo20;
```

求所有领取奖金的人求出平均工资，所有不领取奖金的人求出平均工资:
```
这种问题只能依靠查询的连接操作，第一个查询负责查询出所有领取奖金的雇员，第二个查询所有不领取奖金的雇员。
union
select
select  'comm',avg(sal) from emp where comm is noy null;
```

---

### 序列
再Oracle之中，自动增长列并不是自动控制的，而是需要用户手工控制的，这样主要为了方便

1）create SEQUENCE sequence  --创建序列；
```
create sequence myseq;
```

序列名称 . nextval :让序列增长到下一个内容。
序列名称 . currval :取得当前序列的内容。
```
select myseq.nextval from dual;
select myseq.currval from dual;
```

一般作为主键使用
```
create table tab(
    id number primary key,
    name varchar2(20) not null
)
insert into tab values(myseq.nextval,'姓名');
此时的id编号自动增长。
```

2） [INCREMENT BY n]  [start with n]
```
创建序列，从10开始，每次增长2.
create sequence myseq increment by start with 10;

```

3） [MAXVALUE n | MOMAXVALUE]
4） [MINVALUE n | NOMINVALUE]
5） [CYCLE | NOCYCLE]
```
希望定义一个序列，这个序列可以在1，3，5，7，9之间循环出现。
create sequence myseq increment by 2 start with 1 maxvalue 10 minvalue 1 cycle nocache;
```
6） [CACHE n |  NOCACHE]

在Oracle数据库中。已经为用户准备好了若干个已经生成好的序列，每次操作的时候是从这块空间之中去除序列的内容，但是有这样一个问题，如果现在数据库的实例
关闭了，那么保存的这块空间的内容就消失了，但是虽然消失了，可是数据已经增长好了，这样就会出现跳号的问题。而如果想要取消这种问题，则最好的方式是将序列
设置为不缓存，使用nocache。


---

### 视图索引序列
### 数据表的创建
* 主要数据类型：varchar2、number、date、clob;
* 创建表的语法：create table 表名称 ;
* 删除表的语法：drop table 表名称 ；
* 清空回收站：purge recyclebin .
### 约束：约束是保证表中数据完整性的一种手段，约束一定要在表建立的同时设置好，而且在表真正使用之前一定还要有约束。
* 约束的分类：非空约束(NOT NULL)、唯一约束(UNIQUE)、主键(PRIMARY KEY)、检查(CHECK)、外键(FOREIGN KEY)；
* 设置外键的注意事项：先删除子表在删除主表。
>* 级联删除使用：on delete cascade;
>* 级联设置：on delete set null;
###  序列：sequence,可以形成自动增长。
* 序列中的两个属性：nextval、currval ;
* 序列的操作一定要手工进行控制

### 视图
(重点)
视图创建语法：create [or replace]  view 视图名称 as 子查询

```
在创建视图的时候，不能有分组函数，如果使用，在分组函数后加一个别名。
创建一张视图：
create view myview as
select d.loc,d.dname,d.deptno,count(e.empno) countempno,avg(sal) avgsal
from emp e,dept d
where e.deptno=d.deptno
group by d.deptno,d.dname,d.loc

查询视图：
select * from myview;
视图其实就是包装了SQL查询的操作。
```

另一视图创建语法：create  or replace view 视图名称 as 子查询
```
如果视图存在则进行替换，不存在则创建一张新的视图。但是在创建视图的时存在两个选项。
```

* 选项一： on with check option,更新试图的的时候，由于视图本身并不是一个实际的数据表，而更新操作又是视图的创建条件，很明显，这种做法时不可取得。
```
create or replace view myview as
select * from emp where deptno=7698
on with check option;
```

* 选项二：with read only
```
create or replace view myview as
select * from emp where deptno=7698
with read only;
此时再次更新操作，会提示如下错误：
ORA-01733:此处不允许虚拟列更新，此数据操作非法。
```
与之前得问题一样，现在得视图数据时属于统计而来得，根部不可能更新。视图得数量有可能超过表得数量。


---

### 同义词
语法:
```
create[public] synonym 同义词名称 for 用户名  . 表名
select * from myemp;

create synonym myemp for scott.emp;
这个只限制于scott用户一个人使用，其他用户无法使用。因为创建得不是公共同义词。那么公共同义词是：
create public synonym myemp for scott.emp;
select * from myemp;

Oracle特性！！！！
```
---

### 索引
（理解）
索引得主要功能就是提升数据库得操作性能。
```
利用代码进行分析：
select * from emp where sal>1500;
此时得sal上没有索引，所以它的查询是采用逐行判断的方式完成的，这种操作随着数据量的上升，则性能就会出现越来越多的问题，
但是如果说将数据排列一下呢：

把数据排列在树状结构上的话同样的查询，现在只会查询一部分。这就是索引！！！
```

创建索引方式：
* 主键约束：如果一张表中的裂伤存在了主键约束的话会自动创建索引。
* 手工创建：在某一个操作列上指定一个索引。

```
在emp   sal字段上创建索引。
create index emp_sal_ind on emp(sal);
但是索引有一个最大问题，要想性能提高，就必须维持上面的这棵树，那么如果这棵树的数据频繁的修改，则代码的性能肯定也会降低，

所以索引一般只会使用在不会频繁修改的表中，如果在一张频繁的表中使用索引，肯定会影响性能。所以，性能提升永远是相对的！！！！

Oracle有十几种，这个是最简单的一种，成为B树索引，还有位图索引、反向索引、函数索引等等！！
```

---

### 用户管理
创建新的用户：
格式：
```
conn sys/change_on_install assysdba;
create user dog IDENTIFIED BY wangwang;

提示信息：用户无法登陆，没有创建session权限。
ORA-01045:user dog lacks create session privilege denied;

接下来，给用户授权：
grant create session to dog;
```

但是，新人入职难做人啊！权限少啊，在创建表的时候该用户（dog）也没有权限，为了解决用户的授权操作，在Oracle之中为用户提供了许多角色，每一个角色会包含多个权限，而角色主要有两个：
connect、resource.
```
范例：将这两个角色给权限dog用户：
grant connect,resource to dog;
```

* 管理员修改用户的密码：
```
将dog用户的密码修改为miaomiao:
alter user dog indentified by miaomiao;
```

* 锁定用户：
```
alter user dog account lock;
```

* 解锁用户：
```
alter user dog account unlock;
```

主要的权限有四个：insert  delete   select   update .
* 将scott.emp表的select、insert权限给用户dog;
```
grant select,insert scott.emp to dog;
```

* 回收dog用户权限：
```
revoke select,insert on scott.emp from dog;
删除用户全部权限：
revoke connect,resource,create table,create session from dog;
```

* 删除用户：
```
使用级联删除：
drop user dog cascade;
```

---


























































        
        
