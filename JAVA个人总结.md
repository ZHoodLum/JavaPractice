#关于java一些的日常练习sss

## java环境变量的配置

[java环境变量的配置](#java环境变量的配置)

## Java对象与类

[对象与类](#对象与类)

## Java数据类型

[primitive主数据类型](#primitive主数据类型)

[运算符号](#运算符号)

[避开关键字](#避开关键字)

[引用数据类型](#引用数据类型)

[数组](#数组)

[方法](#方法)

## 面向对象

[类](#类)

[对象](#对象)

[类与对象关系](#类与对象关系)

[类与对象的基本定义](#类与对象的基本定义)

## Java面向面向对象三大特征

[封装](#封装)

[继承](#继承)

[多态](#多态)

---
---


### java环境变量的配置

下面是我对应的JDK安装位置： JDK 位置：C:\Program Files\Java\jdk1.8.0_73

环境变量配置：
* (1) JAVA_HOME 编辑：
C:\Program Files\Java\jdk1.8.0_73

* (2)CLASSPATH 编辑：
%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar

* (3)PATH 点击编辑文本：
%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin

* (4)检查是否环境配置成功
 使用CMD查看环境是否配置成功：java      javac     java -version


### 对象与类

* `对象:` 对象是类的实例，有状态和行为两种属性。状态影响行为，行为影响状态。

* 对象的三个主要特性：
 > 1. 对象的行为（behavior）：可以对对象施加哪些操作、方法；
 > 2. 对象的状态（state）：当施加那些方法时，对象是如何响应的？
 > 3. 对象标识（identity）：如何辨别具有相同行为、状态的不同对象。
      ps:同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。                 
* `类:` 类是一个模板，它用来描述对象的行为和状态。类是构造对象的模板或蓝图。
        由类构造（Contruct）对象过程为创建类的实例（instance）。
* 类之间的关系：依赖（use-a）、聚合（has-a）、继承（is-a）。
* 类包含的类型变量：

>* 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
>* 方法会运用形参。调用的一方会传入实参。实参是传给方法的值，当它传入方法后就成为了形参。参数跟局部变量是一样的。它有类型与名称，可以在方法内使用。
>* 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
>* 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。

---

Java的基本数据类型
--
在java中，变量分为两种：`primitive主数据类型(基本数据类型)`、`引用数据类型` 
### primitive主数据类型
primitive主数据类型(基本数据类型)包括八种：`boolean`,`char`, `byte`,`short`,`int,lon`g,`float,double`对于变量的赋值，都是将某个变量的值赋给另一个变量；这两个变量之间并没有其他什么联系，只是在初次赋值时，其值刚好相等而已；之后则各走各路，并无任何瓜葛；
>* char类型 2字节  short 2字节,char类型与short类型之间,需要转换,比较特殊，表示正数。
>* char类型与char类型运算，晋级为Int类型,然后再进行计算。
* 隐式数据类型的顺序：

	byte < short < int < long < float < double
* 需要强制转换的顺序：

	double > float > long > int > short > byte > char(特殊，表示正数)
* 大类型转换为小类型值，需要进行强制转换：

	float c = 9.0f/2;
	double d = 9.0/2;
	d = c;	//将c赋值给d
	c = (float)d;	//强制类型转换 

* 本节要点
>* 变量有两种：primitive主数据类型和引用
>* 变量的声明必须有类型和名称
>* primitive主数据类型变量值是该值的字节所表示的
>* 引用变量的值代表位于堆之对象的存取方法
>* 引用变量如同遥控器，对引用变量使用圆点云算法可以如同按下遥控器按钮般的存取它的方法或实例变量
>* 没有引用到任何对象的音乐变量的值为null值
>* 数组一定是一个对象，不管所声明的元素是否为primitive主数据类型，并且没有primitive主数据类型的数组，只有装载primitive主数据类型的数组。
	
### 运算符号
* 1、运算符号：+ - * / %
>* int整数类型祥运算时，结果也为整数。
>* % 取模运算，取余运算：

	int c1 = 10%3;
	int c2 = -10%3;
	int c3 = 10%-3;
	int c4 = -10%-3;
	System.out.println(c1);
	System.out.println(c2);
	System.out.println(c3);
	System.out.println(c4);
	综上所述，取模运算，运算结果符号 取决于第一个数值为（正\负）

* 2、赋值运算
>* ++e 先运算 在输出  ； 先进行加减
>* e++ 先使用 在运算  ；先使用在运算
	
>>* 逻辑运算符  || 或  一真则真; && 与  一假则假;  ! 非  颠倒是非
>>* | 暗位或   需要两个或多个条件都为真 才可以通过
>>* != 不等于  ==等于   =赋值
>* 条件运算符   三目运算符

	boolean n = (4 < 2) ? true :false;
	System.out.println(n);
	对4 小于2语句进行判断 ？  真就为true ,否则为flase

* 3、运算符优先级运算 
> 优先级由高到低

 元素符号|说明|
  |-|:-:|
  `var++、var--`|后置操作符
  `+、- ``++var、--var`|(后置操作符);(后置操作符)
  type|类型转换
  !|非
 ` *、/、% `|乘法、除法、求余运算
  +、-|二元加法乘法
  < <+ > >+|比较操作符
  == !=|相等操作符
  ^|异或
  &&|条件与
  `||`|条件或
 ` = += -+ *+ /+ %=`|赋值操作符
> 按操作数多少划分
	一元操作符 > 二元操作符 > 三元操作符
> 按运算类型划分
	算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符
> 尽量多的使用括号
	括号优先级别最高
> 一元运算符，如` -、++、- -和 ! `
> 算术运算符，如` *、/、%、+ 和 -`
> 关系运算符，如 `>、>=、<、<=、== 和 != `
> 逻辑运算符，如` &、^、|、&&、|| `
> 条件运算符和赋值运算符，如 `? ：、=、*=、/=、+= 和 -= `

* 4、&和&&，|和||的用法区别:
 
     &：表示`按位"与"`、&&：表示`条件与`，两者之间的区别是：&会执行两边，不管第一个条件是否成立;
     
    				 &&只会执行一边，如果第一个条件为假，则不会走第二个条件。遵循一假则假规则。
     
     |：表示`按位"或"`、||：表示`条件或`，两者之间的区别是：||只要满足第一个条件，后面的条件就不再判断，
     
     							而|要对所有的条件进行判断。遵循一真则真原则
 
> 逻辑与或同按位与或是有一定区别的：

>> 相同点是：都能参与逻辑运算，按位与或完全可以代替逻辑与或。

>> 区别是：按位与或可以参与位运算，逻辑与或只能参与逻辑运算，逻辑与或可以“短路”，按位与或不能“短路”。	

>> 短路运算
	作用运算符：逻辑与&&，逻辑或||。
	
	如（1）：逻辑表达式：a>b && c>d
		假设a>b 为false，c>d为true，那么整个表达式结果为false;
		假设a>b 为false，c>d为false，那么整个表达式结果还为false;
	可见，a>b的结果已经决定了整个表达式的结果，而后面的c>d并不影响表达式的结果，可以说后半部分被“短路”了。
	如（2）：逻辑表达式： a>b || c>d
		假设a>b 为true，那么后半部分表达式将被“短路”;

 
  
### 避开关键字
* 类、方法、变量命名规则：
>* 名称必须以字母、下划线（）或$符号开头，不能用数字开头。
>* 除了第一个字符外，后面就可以用数字。反正不要用在第一个字符就行。
>* 主要符合上述两条规则，你就可以随意命名，但还要避开Java的保留字。
>* 对象的声明、创建、赋值有三个步骤。 
```
    Dog d    =      new Dog();
    声明     赋值    创建
```
>* pd:转义字符：\   例如：`\\` 输出一个 `\` ;   `\"` 输出一个 `"`

### 引用数据类型
除上述八种primitive主数据类型之外，其余类型都称之为引用数据类型；引用数据类型，顾名思义就是：`引用`，当一个对象赋值给一个引用变量时，那么，则表明这个引用变量是指向这个对象的；一个对象可以有多个引用；一个引用同一时刻，则只能指向一个对象；
>* 事实上没有对象变量这样的东西存在
>* 只有引用(reference)到对象的变量
>* 对于引用变量保存的是存取对象的方法
>* 它并不是对象的容器，而是类似指向对象的指针，或者可以说是地址，但在Java中文名不会也不该知道引用变量中实际装载的是什么，它只是用来代表单一的对象。只有Java虚拟机才会知道如何使用引用来取得该对象。

### 数组
* 定义：数组是一种数据结构，用来存储`同一类型`值的集合。在声明数组变量时，需要指出数组类型（数组元素类型紧跟[]和数组变量的名字。
	eg:        int[] a = new int[100];）
>* 数组中每个元素都是变量,也可以说是8中primitive主数据类型变量中的一种，不然就是引用变量。
>* 创建一个数字数组时，所有元素都初始化为0；一旦创建数组，就不能改变它的大小（尽管可以改变每一个数组元素）。
>* boolean数组的元素会初始化为`flase`,对象数组的元素则初始化为一个特殊值`null`,这表示数组还未存放任何对象。
>* java.lang.ArrayIndexOutOfBoundsException :异常而终止执行，报这种错误，我们称之为`数组下标越界`。
>* 若想获得数组中的元素个数，可以使用array`.length`。

---

方法
--
### 定义
* 1、方法是完成某个功能的一组语句，通常将常用的功能写成一个方法。定义方法就是编写一段有特定功能的代码，在程序中使用同样功能的地方，没有必要重复编写同样的代码，只要调用定义好的方法就可以。可以实现代码的重用。简化了程序的编写和维护工作。方法声明或称为定义方法。

>* 修饰符：public 、static 被称为修饰符（后续会详细讲解它们）；
>* 返回值类型：用来说明该方法运算结果的类型。如果返回其他类型，编译就可能出错；
>* 方法名：它作为调用时引用方法的标识；
>* 形参列表：在方法被调用时用于接受外部传入的变量称为形式参数简称为形参，方法的形参个数可以是0个到多个，每个参数前面要声明参数的数据类型称为参数类型；每个参数要用逗号分开。也可以一个参数都没有。
>* 方法体：它是一个语句块，执行特定的功能操作。对于有返回值类型的方法，方法体当中最后一个语句是return关键字，它的作用是把方法的执行（运算）结果返回到方法外部。	
>* return  表达式：return是关键字，作用是将return后面表达式的结果作为方法的返回值。需要注意表达式的类型，必须与方法头中声明的“返回类型”相匹配。

* 2、方法分类

> 1）根据参数个数：

>> 无参方法

>> 有参方法

>>> 参数类型为基本数据类型

>>> 参数类型为引用数据类型

> 2）根据返回值类型:

>> 有返回值的方法：

>>> 返回值类型为基本数据类型

>>> 返回值类型为引用数据类型

>> 无返回值的方法

>>> 返回值类型使用void关键字

### 总结
1、可以将一些重复执行的代码定义在方法里面，方法（method）在有些书上也被称为函数(Function )。

2、本次方法所讲解的是有它的局限性：定义主类，并且有主方法直接调用。

3、方法返回值一旦定义了，就需要使用return返回相应数据。

4、方法重载（overloading）指的是`方法名称相同`，`参数类型`及`个数`不同，同时尽量保证`返回值类型相同`。

5、递归调用需要明确`设置一个结束条件`，否则就会出现死循环，如果处理数据量过大，就有可能出现`内存溢出`。
### 方法重载
方法的重载（overload），方法的重载就是在同一个类中允许同时存在一个以上同名的方法
> 方法重载的规则
>* 方法名称相同
>* 方法的参数必须`不同`:参数个数不同 或参数类型不同
>* 方法的返回值类型可以相同，也可以不同

面向对象
--
 
### 类
* 什么是类
>> 把相似的对象划归成一个类。
>> 在软件设计中，类，就是一个模板，它定义了通用于一个特定种类的所有对象的属性（变量）和行为（方法）

### 对象
* 什么是对象
>  类(class) — 是对某一类事物的描述
> 对象(object) — 是实际存在的某类事物的个体,也称为实例(instance)
> 注：类是创建对象的模板，对象是类的实例。

### 类与对象关系
>* 类与对象是整个面向对象之中最为基础的组成单元，如果需要给出划分定义，类是共性的集合，而对象是某一个性的产物,所有类实际上都是描述出对象的结构。
>* 一类的共性的集合对象，除了具备以上特征（属性）之外，实际上还包括许多的行为（功能），所以根据此类产生出的对象都具备相同的行为。
>* 对象所能够操作的行为都是有类来决定的，超过类定义范畴的操作是不能够使用的
>* 类实际上的对象操作的模板，但是类不能够直接使用，但必须通过实例对象来使用。（先有类再有对象）
>* 类是不能直接使用的，对象是可以直接使用的，对象是可以通过类产生的。 
 
### 类与对象的基本定义
* 1、如果在程序之中定义类可以使用“class 类名称”的语法结构组成，而类之中主要有两点：
>* Field(属性、成员、变量)：就是一堆变量的集合。
>* methed(方法、行为)：之前见到的方法，此时方法是由对象调用的。

* 2、对象定义格式：
>* 声明并实例化对象：类名称 对象名称 = new 类名称（）；
>>* 注：引用数据类型与基本数据类型最大的不同在于需要内存的开辟及使用，所以关键字new的主要功能就是开辟内存空间。即，只要是引用数据类型想使用，那么就必须使用关键字new来开辟空间。
* 3、内存分析，首先可以给出两块内存空间的概念：
>>* 堆内存：保存每一个对象的属性内容，堆内存需要用关键字new才可以开辟内存空间
>>* 栈内存：保存一块堆内存的地址。但是为了分析方便，栈内存保存的是对象的名字。

* 4、当一个对象实例化之后那么就可以按照如下的方式利用对象来操作类的结构
>>* 对象.属性：表示要操作类中的属性内容。
>>* 对象.方法()：表示要调用类中的方法。 

* 5、当使用没有实例化对象，在程序运行时，会出现“NullPointeException”空指针指向异常，此类异常只要是引用数据类型都有可能出现。
>* 注：String 首字母大写的都是类名称，类名称都是引用类型，引用类型的默认值是空。
>*     double是基本数据类型，默认值是0.0

Java面向对象的三大特征：
--
封装、继承、多态。封装和继承几乎都是为多态而准备的

### 封装
首先，属性能够描述事物的特征，方法能够描述事物的动作。封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。封装：封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。

### 封装的好处：
>* 实现了专业的分工。
>* 良好的封装能够减少耦合。
>* 类内部的结构能够自有修改。
>* 可以对成员进行更精确的控制。
>* 隐藏信息，实现细节。
>* 使用公有与私有这两个存取修饰符来`隐藏数据`。
>* 封装原则：将你的实例变量标记为私有的，并提供公有的getter与setter类控制存取动作。
>* 将实例变量标记为private。将getter与setter标记为public。任何有值可以被运用到的地方，都可调用方法的方式来取得该类型的值。

### 封装的步骤
>* 修改属性的可见性来限制对属性的访问
>* 为每个属性创建一队赋值和取值方法，用于对这些属性的访问
>* 在赋值和取值方法中，加入对属性的存取限制
>* 为了实现良好的封装，我们通常将类的成员变量声明为private，在通过public方法来对这个变量来访问。对一个变量的操作，一般有读取`getter`和赋值
`setter`2个操作，我们分别定义2个方法来实现这2个操作，一个是getXX（XX表示要访问的成员变量的名字）用来读取这个成员变量，另一个是setXX（）用来对这个变量赋值。
下面我们来看下这个例子：
```
    public class Husband {
    /*

     * 对属性的封装一个人的姓名、性别、年龄、妻子都是这个人的私有属性

     */
    private String name;

    private String sex;

    private int age;

    private Wife wife;

    /*

     * setter()、getter()是该对象对外开发的接口

     */

    public String getName() {

        return name;

    }
    public void setName(String name) {

        this.name = name;

    }
    public String getSex() {

        return sex;

    }
    public void setSex(String sex) {

        this.sex = sex;

    }
    public int getAge() {

        return age;

    }

 

    public void setAge(int age) {

        this.age = age;

    }
    public void setWife(Wife wife) {

        this.wife = wife;

    }

}
```
### 继承
1. Java继承
--
Java继承是面向对象的最显著的一个特征。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。JAVA不支持多继承，单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序，父类是子类的一般化，子类是父类的特化（具体化)继承所表达的就是一种对象类之间的相交关系，它使得某类对象可以继承另外一类对象的数据成员和成员方法。若类B继承类A，则属于B的对象便具有类A的全部或部分性质(数据属性)和功能(操作)，我们称被继承的类A为基类、父类或超类，而称继承类B为A的派生类或子类。继承避免了对一般类和特殊类之间共同特征进行的重复描述。同时，通过继承可以清晰地表达每一项共同特征所适应的概念范围在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。

2. Java继承的特征
--
>* 继承关系是传递的。若类C继承类B，类B继承类A（多继承），则类C既有从类B那里继承下来的属性与方法，也有从类A那里继承下来的属性与方法，还可以有自己新定义的属性和方法。继承来的属性和方法尽管是隐式的，但仍是类C的属性和方法。
>* 继承提供了软件复用功能。若类B继承类A，那么建立类B时只需要再描述与基类(类A)不同的少量特征(数据成员和成员方法)即可。这种做法能减小代码和数据的冗余度，大大增加程序的重用性。
>* 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性。

3. 继承的实例
--
```
class Person1 {

       public String name = "xiaomiao";

       public int age = 20;

}
class Student extends Person1 {

       void study() {

              System.out.println("I can study!");
       }

}
public class JiCheng {

       public static void main(String args[]) {

              Student stu = new Student();

              // stu.name = "zhangsan";

              // stu.age = 20;

              System.out.println("name=" + stu.name + ",,," + "age=" + stu.age);

       }

}
```

### 多态

>* 方法的重写、重载与动态连接构成多态性； Java之所以引入多态的概念，原因之一是它在类的继承问题上和C++不同，后者允许多继承，这确实给其带来的非常强大的功能，但是复杂的继承关系也给C++开发者带来了更大的麻烦，为了规避风险，Java只允许单继承，派生类与基类间有IS-A的关系（即“猫”is a “动物”）。这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，
此外，抽象类和接口也是解决单继承规定限制的重要手段。同时，多态也是面向对象编程的精髓所在。 要理解多态性，首先要知道什么是“向上转型”。 
>* 我定义了一个子类Cat，它继承了Animal类，那么后者就是前者的父类。我可以通过Cat c = new Cat();       例化一个Cat的对象，这个不难理解。但当我这样定义时： Animal a = new Cat();这代表什么意思呢？很简单，它表示我定义了一个Animal类型的引用，指向新建的Cat类型的对象。由于Cat是继承自它的父类Animal，
所以Animal类型的引用是可以指向Cat类型的对象的。那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，
又可以抽取父类的共性。所以， 父类引用只能调用父类中存在的方法和属性，不能调用子类的扩展部分；因为父类引用指向的是堆中子类对象继承的父类；（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。） 同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。
  
  
  
  
  


